## 1 类型别名
使用type关键字可以定义一个类型别名
```rust
type Kilometer = i32;
```
类型别名主要是为了减少复杂类型的重复命名
```rust
type Thunk = Box<dyn Fn() + Send + 'static>;
let f: Thunk = Box::new(|| println!("hi"));
```
## 2 Never type
`!`为`Never type`。用于指定一个函数永远不会返回任何值。可以表示空类型
常用于match表达式中，match的所有分支都需要返回相同类型的值，但是有些分支无法确定返回值，就可以使用`Never type`，`Never type`可以被强制转换为其他所有类型的值：
```rust
let guess = match guess.trim().parse() {
  Ok(num) => num,
  Err(_) => continue, //while循环中的countine就是一个返回never type的表达式
};
```
panic!宏的返回值也是Never type。
## 3 动态大小类型（DST）和Sized trait
一些类型的值的大小只有编译时才能确定，例如str（不是&str）。这种类型的值是不能直接定义的，必须通过引用类型或指针来使用。
例如str类型在程序当中是不可直接使用的，只能通过&str获取指针。str存储在栈上面（使用`Vec<u8>`实现），是String和&str的底层类型（String是指向str的胖指针）。
绝大多数类型以及默认的泛型都满足Sized trait。但是动态大小类型不满足。如果一个类型是动态大小类型，那么必须加上指针或者引用&符号或者Box包裹才能使用（但是`Box<str>`不行）。
```rust
fn generic<T: ?Sized>(t: &T) {}
```
常见的DST类型还有trait对象。函数的trait object参数必须是`Box<dyn trait>`或者`&dyn trait`。
## 4 高级函数和闭包
闭包和函数也可以当作一个变量来使用，这个变量就是一个函数指针类型的数据。类型为`fn`（不同于`trait Fn`），写法为`f: fn(T) -> T`。
函数指针默认实现了三种闭包trait（Fn、MutFn、FnOnce）。
```rust
//这里的f参数就是一个fn类型的函数指针
fn do_some_times(f: fn(i32) -> i32, args: vec<i32>) {
  let mut count: i32 = 0;
  for val in args {
    count += f(val);
  }
}
let list1 = vec![1,2,3];
//将to_string方法作为参数传入
let list2 = list1.iter().map(ToString::to_string).collect();
```
## 5 返回一个闭包
rust默认不能返回一个函数指针类型。但是可以返回一个独特类型的闭包。有两种方式：
1、返回实现了三大函数trait的闭包
```rust
fn returns_closure() -> impl Fn(i32) -> i32 {
  |x| x + 1
}
```
2、返回trait object
```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
  Box::(new |x| x + 1)
}
```
