宏是一种元编码。可以将一段代码扩展成拥有更多功能的代码。并且宏可以接收不定数量的参数。
宏接收的参数是代码结构本身，会在编译时将代码结构展开。
## 1  声明式宏
声明式宏可以用来匹配宏接收的表达式，根据匹配结果生成新的代码。这是`vec!`宏的定义，只有一个匹配语句：
```rust
//这个注解声明宏可以通过crate访问到
#[marcro_export]
//macro_rules!为声明宏的关键字
macro_rules! vec {
  ( $( $x:expr ),* ) => {
    {
      let mut temp_vec = Vec::new();
      $(
        temp_vec.push($x);
      )*
      temp_vec
    }
  }
}
```
`($($x:expr),*)=>{}`是模式匹配语法。`$(...)`是表示重复模式的语法，即接收的是多个重复类型的参数，`$x:expr`表示命名了一个参数`$x`，这个参数是个expr类型即任意类型的表达式。`,`表示每个参数之间的分隔符，最后的`*`表示重复的次数可以为0次或多次。
## 2 过程宏
过程宏可以接收一段代码作为输入，并输出另一段代码。过程宏是一个函数，接收一个TokenStream类型的参数，并返回相同类型。TokenStream就是宏处理的源代码类型。同时要加一个属性声明过程宏的类型。
过程宏有三种：
1. 派生宏（derive）
**语法**：`#[derive(MyTrait)]`
派生宏只能作用于结构体、枚举或union。不能修改这些类型本身的数据，只能为这些类型实现新的字段和方法。典型代表是
```rust
#[derive(Debug, Clone, PartialEq)] s
truct Point { x: i32, y: i32 }
```
编译器自动生成 `Debug::fmt`、`Clone::clone`、`PartialEq::eq` 等实现。
2. 属性宏（attr）
**语法**：`#[my_attr(...)]`
属性宏可以作用于任何目标，包括任意函数、结构体、trait、模块等，接收整个被修饰项的 AST，可**任意修改、包装或生成新代码**
典型代表是`#[tokio::main]`
3. 函数宏（function）
 **语法**：`my_macro!(...)`
函数宏也可以作用任何位置，将宏调用替换为生成的代码，类似函数但更灵活。
```rust
let q = sqlx::query!("SELECT * FROM users"); // 过程式函数宏（编译期SQL检查）
```