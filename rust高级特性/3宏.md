宏是一种元编码。可以将一段代码扩展成拥有更多功能的代码。并且宏可以接收不定数量的参数。
宏接收的参数是代码结构本身，会在编译时将代码结构展开。
## 1  声明式宏
声明式宏可以用来匹配宏接收的表达式，根据匹配结果生成新的代码。这是`vec!`宏的定义，只有一个匹配语句：
```rust
//这个注解声明宏可以通过crate访问到
#[marcro_export]
//macro_rules!为声明宏的关键字
macro_rules! vec {
  ( $( $x:expr ),* ) => {
    {
      let mut temp_vec = Vec::new();
      $(
        temp_vec.push($x);
      )*
      temp_vec
    }
  }
}
```
`($($x:expr),*)=>{}`是模式匹配语法。`$(...)`是表示重复模式的语法，即接收的是多个重复类型的参数，`$x:expr`表示命名了一个参数`$x`，这个参数是个expr类型即任意类型的表达式。`,`表示每个参数之间的分隔符，最后的`*`表示重复的次数可以为0次或多次。
## 2 过程宏
过程宏可以接收一段代码作为输入，并输出另一段代码。过程宏是一个函数，接收一个TokenStream类型的参数，并返回相同类型。TokenStream就是宏处理的源代码类型。同时要加一个属性声明过程宏的类型。
过程宏有三种：
自定义派生宏（derive）
属性宏（attr）
函数宏（function）

