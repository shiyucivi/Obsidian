`axum`规定所有handler要么没有参数，要么参数必须是实现了提取器trait的类型。`axum::extract`提供了多种请求数据的提取器，用于从请求路由、url、请求体、header中提取数据。
### 1 路由参数提取Path
路由中的动态参数通常使用`:`前缀的占位符表示。可以使用`extract::Path`来提取。`Path`是一个元组类型，元组中包含路由中的动态参数。
```rust
use axum::{routing::get, Router, extract::Path, serve};
#[tokio::main]
async fn main() {
	let router = Router::new().router("user/:id", get(user_handler));
	let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await.unwrap();
	serve(listener, router).await.unwrap();
}
async user_handler(Path(user_id): Path<u32>) -> String {
	format!("User id is {}", user_id)
}
```
如果存在多个动态路由参数，可以按顺序从`Path`的元组中提取。
### 2 Query
最常见的方式是使用`extract::Query`提取器搭配`Deserialize`反序列化。假如url是`/search?name=XXX&age=18`：
```rust
use axum::{extract:: Query, routing::get, Router};
use serde::Deserialize;
#[derive(Deserialize)]
struct User {
	name: String,
	age: u32
}
#[tokio::main]
async fn main() {
	axum::serve(tokio::net::TcpListener::bind("127.0.0.1:3000"), 
		Router::new().route("/search", get(search_handler)));
}
async search_handler(Query(params): Query<SearchParmas>) -> String {
	// params的类型是User
	format!("Hello {}! You are {} years old.", params.name, params.age)
}
```
如果序列化错误（例如字段类型不匹配），Axum会自动返回`400 Bad Request`。如果查询参数是可选的，可以使用`Option`将字段包裹：
```rust
struct Person {
	name: Option<String>,
	age: Option<u32>
}
```
如果参数是动态类型的参数，也可以序列化为`HashMap`类型：
```rust
use std::collections::HashMap;
async fn search(Query(params): Query<HashMap<String, String>>) -> String {
    format!("{:?}", params)
}
```
### 3 JSON
使用`axum::extract::Json`提取器搭配`serde::Deserialize`即可：
```rust
use serde::{Deserialize, Serialize};
use axum::{extract:: Json, routing::get, Router};
#[derive(Deserialize)]
struct CreateUser {
	name: String, age: u32
}
#[derive(Serialize)]
struct UserResponse {
	id: u64, name: String, age: u32
}
fn create_user_handler(Json(params): Json<CreateUser>) -> (StatusCode, Json<UserResponse>) {
    let user = UserResponse {
        id: 123,
        name: payload.name,
        age: payload.age,
    };
    (StatusCode::CREATED, Json(user))
}
```
### 4 FormData
由于FormData字段通常包含多种格式，并可能存在重复字段。Axum没有直接提供将FormData反序列化的提取器。一般使用`extract::MultiPart`提取器。这个提取器是一个异步流Stream，使用循环+`next_field`方法逐个读取每个字段。
```rust
use axum::{
	//需要在cargo中添加Multipart features
    extract::{Multipart, Path},
    response::IntoResponse,
    routing::post,
    Router,
};
use std::io::Read;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
#[tokio::main]
async fn main() {
	let app = Router::new().route("/upload", post(handle_upload));
}
async fn upload_handler(mut multipart: Mulitpart) -> Result<String,(http::StatusCode, String)> {
	//while let循环 + next_field遍历每个字段
	while let Some(filed) = multipart.next_field().await.map_err(internal_error)? {
		// filed.name方法获取每个字段的名称
		let name = field.name().unwrap_or("unknown").to_string();
		// field.file_name方法获取每个字段的文件名（如果不是文件返回None）
        let file_name = field.file_name().map(|s| s.to_string());
		// 如果是文件
		if let Some(file_name) = file_name {
			// 转换为bytes
			let data = field.bytes().await.map_err(internal_error)?;
            let path = format!("./uploads/{}", file_name);
            // 创建空文件
            let mut file = File::create(&path).await.map_err(internal_error)?;
            // 写入文件
            file.write_all(&data).await.map_err(internal_error)?;
		} else { //不是文件，通常会被转为字符串
			let data = field.bytes.to_str().map_err(internal_error)?;
			println!("field {}: {}", name, data);
		}
	}
	Ok(http::StatusCode::Ok, "upload_success")
}
// 错误转换，将所有错误转换为Response
fn internal_error<E>(err: E) -> (http::StatusCode, String)
where E: std::error::Error {
    (http::StatusCode::INTERNAL_SERVER_ERROR, err.to_string())
}
```
### 5 Header
通过`http::HeaderMap`获取Map。
```rust
use axum::{
	http::{HeaderMap}
}
async fn handler(headers: HeaderMap) {
	let user_agent = headers.get("user-agent")
	.and_then(|v| v.to_str().ok()).unwrap_or("Unknown");
}
```
### 6 String`/`Bytes
如果想不解析直接提取请求的body中的原始数据（字符串或二进制字节流）。
#### 6.1 String提取器
axum默认为String类型实现了`FromRequest` trait。只要header的 Content-Type 是文本类型，提取器就会自动尝试把字节流解码为UTF8字符串（解码失败则报错）：
```rust
use axum::{
    routing::post,
    Router,
};
// 使用 String 提取整个 body
async fn echo_body(body: String) -> String {
    format!("You sent: {}", body)
}
```
#### 6.2 Bytes提取器
Bytes提取器适合处理原始二进制数据。适合处理文件图像等信息。其中Bytes类型源自于Bytes crate。
```rust
use axum::{
    routing::post,
    Router,
    body::Bytes,
};
async fn handler_bytes(bytes: Bytes) {
	println!("bytes has : {}", bytes.len());
}
```
### 7 多个提取器
如果在一个handler中想同时提取多个部分，只需要在handler的参数中传入多个提取器即可。注意只能有一个消耗请求体的提取器。
```rust
use axum::{
    routing::post,
    Router,
    extract::Json,
    http::StatusCode,
};
async fn handler(headers: HeaderMap, Json(json_body): Json<Payload>) -> String {
	let user_agent = headers.get("user-agent").
		and_then(|v| v.to_str().ok()).unwrap_or("Unknown");
	tracing::info!("json body: {:?}", json_body);
	format!("User-Agent: {}, json body: {:?}", user_agent, json_body)
}
```
### 8 Request、Body与Stream流处理
`Request<T>`是handler提取请求的原始数据类型。通常使用`Request::into_parts`方法将其分割为一个`Parts`类型（http请求的原数据）和一个`Body`类型（请求体载荷），`Parts`类型包含了请求的method、uri、header等数据。
#### 8.1 Body
`axum::body::Body`类型是一个实现了`Stream<Item = Result<Bytes, Error>>`的异步流。可以使用异步Stream相关的迭代器或适配器进行处理，特别是当请求body极大需要分块处理时。
`Body`也可以作为提取器使用直接提取请求体，但是`Body`并没有实现`FromRequest`，而是axum对`Body`做了特殊处理。可以使用`into_data_stream`方法将`Body`转为异步Stream再进行处理：
```rust
use axum::{
	body::Body
};
//需要导入StreamExt trait，为Stream类型实现了next迭代方法
use tokio_stream::StreamExt;
use std::time::Duration;
use tokio::{io::AsyncWriteExt}

async fn upload_handler(body: Body) -> Result<impl IntoResponse, (StatusCode, String)> {
	let mut file = tokio::fs::File::create("/upload.bin").await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
	let mut body_stream = body.into_data_stream();
	while let Some(chunk) = body_stream.next().await {
		let chunk = chunk..map_err(|e| (
			StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
		)?;
		file.write_all(chunk).await..map_err(|e| 
			(StatusCode::INTERNAL_SERVER_ERROR, e.to_string())
		)?;
	}
	Ok((StatusCode::OK, "upload success"))
}
```
`tokio_stream::StreamExt`和`http_body_util::BodyExt`是常用的两个处理Body Stream的trait。
#### 8.2 作为提取器的`Request`
`Request`本身也是一个实现了`FromRequest`的提取器。通常使用`Request<Body>`作为提取器类型来提取原始的Body：
```rust
use axum::{body::Body, http::Request};
use http_body_util::BodyExt; // 提供 to_bytes(), collect() 等的trait

async fn handler(req: Request<Body>) {
	//方式1：一次性读取到内存中
	let bytes = req.into_body().collect().await.unwrap().to_bytes();
	//方式2：流式处理
    let mut body = req.into_body();
    // frame方法获取的是包含meta data的原始帧，通常只需要用into_data_stream获取数据部分
    while let Some(chunk) = body.frame().await {
        let chunk = chunk.unwrap();
        if let Ok(data) = chunk.into_data() {
            println!("Chunk: {:?}", data);
        }
    }
}
```






