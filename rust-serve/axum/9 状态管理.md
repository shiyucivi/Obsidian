### 1 全局状态共享
状态（state）是多个路由之间可以共享访问和修改的数据。常用于配置文件或者数据库连接池等。
axum提供了`with_state`方法为一个Router注入一个共享状态。`extract:State`可以在handler中提取这个共享状态。
`State`提取器获取到的是状态的不可变引用，因此对于可修改字段必须使用原子引用+锁（对于异步handler需要考虑异步锁）。
```rust
use axum::{
    routing::get,
    Router,
    extract::State,
    http::StatusCode,
};
use std::sync::{Arc, Mutex};

// 定义应用状态
#[derive(Clone)]
struct AppState {
    counter: Arc<Mutex<u32>>,
}
#[tokio::main]
async fn main() {
    let shared_state = AppState {
        counter: Arc::new(Mutex::new(0)),
    };
    let app = Router::new().route("/inc", get(increment))
        .with_state(shared_state);
    axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
        .serve(app.into_make_service())
        .await
}
async fn increment(State(state): State<AppState>) -> (StatusCode, String) {
    let mut counter = state.counter.lock().unwrap();
    *counter += 1;
    (StatusCode::OK, format!("Counter: {}", counter))
}
```
对于使用`Nest`和`Merge`的嵌套或合并路由，有两条规则：
1. 同一个服务下的Router必须使用相同的State类型。
```rust
struct StateA { x: i32 }
struct StateB { y: String }
let router_a = Router::new()
    .route("/a", get(|State(_): State<StateA>| async {}))
    .with_state(StateA { x: 1 });
let router_b = Router::new()
    .route("/b", get(|State(_): State<StateB>| async {}))
    .with_state(StateB { y: "hello".into() });
let app = router_a.merge(router.b); 
// ❌ 两个router的State是不同类型
```
正确做法是将所有状态合并，这是系统设计的重要原则：统一的共享状态
```rust
struct AppState {
	x: i32,
	y: String
}
```
2. 如果router在不同作用域中定义，router需要显式声明State类型，编译器无法推断出router的State类型。
```rust
let state = AppState {};
Router::new().nest("/api", make_api())
        .with_state(state)
        
fn make_api_router() -> Router<AppVersion> {
    Router::new().route("/api", get(hello))
}​
```
Axum 的 `Router::with_state(state)` 要求状态类型 `S` 实现 `Clone` trait。因为Axum 内部会将传入的状态包装为 `Arc<S>`，在构建路由和中间件时，也可能需要多次克隆状态的引用或值。

除了`with_state`共享状态，axum还提供了`extension`、闭包捕获等共享机制。但`with_state`是最推荐的共享状态方法。
### 2 子状态共享
可以使用substates + FromRef的方式，让部分handler只共享部分子状态：
```rust
use axum::Router;
use axum::extract::{FromRef, State};
use axum::routing::{get, post};
use axum::handler::Handler;
#[derive(Clone)]
struct SubState {
    version: &'static str,
}
#[derive(Clone)]
struct AppState {
    sub_state: SubState,
}
impl FromRef<AppState> for SubState {
    fn from_ref(app_state: &AppState) -> Self {
        app_state.sub_state.clone()
    }
}
#[tokio::main]
async fn main() {
	let state_a = SubState {
		 version: "1.0.0",
	};
	let app_state = AppState {
		sub_state: state_a,
	};​
	let app = Router::new()
		.route("/handler", get(handler))
		.with_state(app_state);
}
async fn handler_a(State(state): State(SubStateA)) {
	println!("{state.version}");
}
```