“注入依赖”通常就是指通过共享状态，将一些动态或配置化的数据（比如数据库连接池、配置对象、服务实例等）传递给 handler 函数。通常有两种方式：动态trait对象注入和泛型注入。
### 1 动态trait对象注入
- 优点是类型参数更少，代码简洁
- 缺点是必须使用对象安全的trait（trait中的方法不能存在泛型或返回`Self`类型），并且存在运行时损耗。
动态trait对象注入是优先考虑的注入方式，除非很难写出满足要求的trait。
```rust
// 将内存中的一个用户仓库（HashMap存储）注入状态，进行读取和写入的示例
use std::{
	collections::HashMap,
    sync::{Arc, Mutex},
};
use axum::{
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
#[tokio::main]
async fn main() {
	let user_repo = InMemoryUserRepo::default();
	let using_dyn = Router::new()
		.route("/users/{id}", get(get_user_dyn))
		.route("/users", post(create_user_dyn))
		.with_state(AppStateDyn {
			user_repo: Arc::new(user_repo.clone()),
		});
}

trait UserRepo: Send + Sync {
    fn get_user(&self, id: Uuid) -> Option<User>;
    fn save_user(&self, user: &User);
}	
#[derve(clone)]	
struct AppStateDyn {
	user_repo: Arc<dyn UserRepo>
}
#[derive(Debug, Clone, Default)]
struct InMemoryUserRepo {
	map: Arc<Mutex<HashMap<Uuid, User>>>,
}
impl UserRepo for InMemoryUserRepo {
	fn get_user(&self, id: Uuid) -> Option<User> {
		self.map.lock().unwrap().get(id).clone()
	}
	fn save_user(&self, id: &User) {
		self.map
	}
}
#[derive(Debug, Serialize, Clone)]
struct User {
    id: Uuid,
    name: String,
}
#[derive(Deserialize)]
struct UserParams {
    name: String,
}
async fn create_user_dyn(
    State(state): State<AppStateDyn>,
    Json(params): Json<UserParams>,
) -> Json<User> {
    let user = User {
        id: Uuid::new_v4(),
        name: params.name,
    };
    state.user_repo.save_user(&user);
    Json(user)
}
async fn get_user_dyn(
    State(state): State<AppStateDyn>,
    Path(id): Path<Uuid>,
) -> Result<Json<User>, StatusCode> {
    match state.user_repo.get_user(id) {
	    Some(user) => Json(User),
	    None => Err(StatusCode::NOT_FOUND),
    }
}
```
### 2 泛型注入
- 优点：更灵活，因为可以使用所有 trait。没有运行时开销。
- 缺点：额外的类型参数和 trait 约束可能会导致代码更复杂。
```rust
#[tokio::main]
async fn main() {
	let user_repo = InMemoryUserRepo::default();
	let using_dyn = Router::new()
		.route("/users/{id}", get(get_user_generic::<InMemoryRepo>))
		.route("/users", post(create_user_generic::InMemoryRepo))
		.with_state(AppStateGeneric {
			user_repo: user_repo,
		});
}
#[derve(clone)]	
struct AppStateGeneric<T> {
	user_repo: T
}
async fn create_user_generic<T>(
	State(state): State<AppStateGeneric>,
	Json(param): Json<UserParams>) -> Json<User>
	where T: UserRepo
{
	let user = User {
        id: Uuid::new_v4(),
        name: params.name,
    };
    state.user_repo.save_user(&user);
    Json(user)
}
async fn get_user_generic<T>(
	State(state): State<AppStateGeneric<T>>,
	Path(id): Path<Uuid) -> Result<Json<User>, StatusCode> 
	where T: UserRepo
{
	match state.user_repo.get_user(id) {
		Some(user) -> Json(user),
		None => Err(StatusCode::NOT_FOUND),
	}
}
```