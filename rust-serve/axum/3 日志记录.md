`tracing`和`tracing-subscriber`是构成日志系统的核心crate。其中`tracing`提供了事件追踪的核心trait和宏，决定了何时产生日志与日志的输出结构等，但不直接输出日志。而是由`tracing-subscriber`提供了日志输出的多种方式，通常`tracing-subscriber`会将日志输出到控制台当中。
### 1 基础用法
#### 1.1 添加依赖：
```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
tower-http = { version = "0.5", features = ["trace"] }
```
#### 1.2  在main函数中初始化`tracing_subscriber`
```rust
// 初始化 tracing subscriber：启用控制台输出 + 从 RUST_LOG 环境变量过滤日志级别
async fn main() {
	tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();
}
```
还有一种初始化方式：
```rust
tracing_subscriber::registry()
	.with(tracing_subscriber::EnvFilter::from_default_env())
	.with(tracing_subscriber::fmt::layer())
	.init();
```
这两种方式实际上等价。`registry().init()`会创建一个订阅者容器，但不会主动监听events，而是需要手动添加layer（处理events的插件，例如`fmt::layer`会创建一个打印输出的layer）。适合于需要组合多个layer的场景。
#### 1.3 通过环境变量控制日志级别
```bash
RUST_LOG=info cargo run      # 只显示 info 及以上
RUST_LOG=my_web_app=debug cargo run  # 仅 my_web_app crate 的 debug 日志
```
在powershell中通过这些命令来设置环境变量：
```shell
$env:RUST_LOG="debug"; cargo run
```
#### 1.4 在handler中使用`tracing`记录日志
```rust
use tracing::{info, debug, warn};
async fn get_hello() -> &'static str {
	info!("Handler get_hello");
	debug!("This is a debug message");
	"Hello world!"
}
```
### 2 日志级别与日志过滤
tracing提供了5个标准基本的日志，从低到高分别为：
`TRACING`、`DEBUG`、`INFO`、`WARN`、`ERROR`。每个级别都有对应的宏。例如：
```rust
use tracing::{error, warn, info, debug, trace};
error!("Database connection failed");
info!("User {} logged in", user_id);
```
日志输出的过滤方式则由`tracing-subscriber`提供，最常用的是基于环境变量进行过滤：
```rust
use tracing_subscriber::EnvFilter;

// 从环境变量 RUST_LOG 读取过滤规则
let filter = EnvFilter::from_default_env();
// 创建subscriber
tracing_subscriber::fmt()
        .with_env_filter(filter)
        .init();
```
也可以用一个字符串来指定过滤级别：
```rust
let filter = EnvFilter::new("info");
let filter = EnvFilter::new("my_crate=debug");
let filter = EnvFilter::new("warn,my_crate::db=trace");
```
### 3 span与日志中间件
span（跨度）是对日志的分块，所有在一个span中的日志都会带上这个span的名称、自定义的字段等信息。可以使我们方便地追踪一个日志所发生的位置。
#### 3.1 使用`tower_http::trace::TraceLayer`日志中间件
```rust
use tower_http::trace::TraceLayer;

let app = Router::new()
    .route("/hello", get(hello))
    .layer(TraceLayer::new_for_http());
```
这个中间件会字段为每个http请求的handler创建一个span。这个span的默认名称是`request`，还包括`method`、`url`、`status`等字段信息。
这个中间件可以使用`make_span_with`来自定义每个http请求对应span的名称、字段等信息。
```rust
use tower_http::trace::{TraceLayer, DefaultMakeSpan};
use tracing::Level;

let trace_layer = TraceLayer::new_for_http()
    .make_span_with(|req| {
        // 自定义 Span 名称和字段
        tracing::info_span!(
            "http_request", // 这是 Span 的名称
            method = %req.method(),
            uri = %req.uri(),
            version = ?req.version(),
            route = "/hello", // 自定义字段
        )
    });
```
#### 3.2 在handler中手动创建span
```rust
use tracing::{info, span, Level};
async fn hello() -> &'static str {
    // 手动创建一个等级为INFO名为 "greet_user" 的 Span
    let _guard = span!(Level::INFO, "greet_user", user_id = 42).entered();
    info!("Preparing greeting message");
    "Hello!"
}
```
### 4 结构化字段
`tracing`的`info!`、`debug!`等宏均提供了结构化输出方式
```rust
let user_id = 123;
let email = "238186@g.com";
info!(user_id, emial, "User logged in");
// 输出：INFO ... user_id=123 email="user@example.com" User logged in
```
### 5 自定义日志文件
默认的`tracing_subscriber`将日志输出到标准输出（stdot，通常是控制台）。如果想记录日志文件，需要使用`tracing-appender`crate，它提供了异步创建与写入日志的方式：
- 添加依赖
```toml
[dependencies]
tracing-appender = "0.2"
```
- 初始化日志文件
```rust
use axum::{routing::get, Router};
use tower_http::trace::TraceLayer;
use tracing_subscriber::{
    fmt,
    layer::SubscriberExt,
    util::SubscriberInitExt,
    EnvFilter,
};
use tracing_appender::rolling;
use std::fs;

#[tokio::main]
async fn main() {
    // 创建日志目录
    fs::create_dir_all("logs").expect("Failed to create logs dir");
    // 设置每日滚动的日志文件
    let file_appender = rolling::daily("logs", "web.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);

    // 构建文件日志 Layer（JSON 格式更利于分析）
    let file_layer = fmt::layer()
        .with_writer(non_blocking)
        .with_ansi(false)          // 文件不需要颜色
        .with_span_events(fmt::format::FmtSpan::CLOSE) // 记录 span 结束时的耗时/状态
        .json();                   // 使用 JSON 格式（可选）

    // 可选：保留控制台输出（开发时方便）
    let console_layer = fmt::layer().pretty();

    // 组合并初始化全局 subscriber
    tracing_subscriber::registry()
        .with(console_layer)       // 注释掉这行则只写文件
        .with(file_layer)
        .with(EnvFilter::from_default_env())
        .init();

    // 构建 Axum 应用 + TraceLayer
    let app = Router::new()
        .route("/hello", get(hello))
        .layer(TraceLayer::new_for_http());

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    tracing::info!("Server running on http://0.0.0.0:3000");
    axum::serve(listener, app).await.unwrap();
}

async fn hello() -> &'static str {
    tracing::info!("Handling /hello");
    "Hello, world!"
}
```