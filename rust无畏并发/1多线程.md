n## 1 进程与线程
一段运行中的代码就是一个进程。而代码内部可以有多个独立运行的线程。
多线程必须面对的问题：
竞态：线程以错误的顺序访问数据或资源
死锁：两个线程互相等待对方完成某个操作，导致两个线程都处于停滞
## 2 创建线程
可以使用`thread::spawn`方法创建一个线程。这个线程依附于主线程。主线程结束从线程也会结束。==**这个方法的参数必须是一个实现了FnOnce的函数或闭包。**==
```rust
use std::thread;
fn hello_from_spawn() {
  for i in 1..10 {
    println!("hello {i} from spawn");
  }
}
fn main() {
  thread::spawn(hello_from_spawn);
  for i in 1..10 {
    println!("hello {i} from main");
  }
}
```
主线程和从线程的执行顺序不会保证每次一致。有可能先执行主线程也可能先执行从线程。
### 2.1 join Handles
为了避免主线程提前结束从线程。可以将一个线程存到变量中（`thread::spawn`返回的类型是`JoinHandle`），这个变量拥有线程的所有权。可以调用这个JoinHandle的join方法。这个方法会阻塞当前运行中的线程，直到JoinHandle执行完毕。
```rust
fn hello_from_spawn() {
  for i in 1..10 {
    println!("hello {i} from spawn");
  }
}
fn main() {
  let handler = thread::spawn(|| {
	for i in 1..10 {
      println!("hello {i} from spawn");
    }
  });
  for i in 1..10 {
    println!("hello {i} from main");
  }
  handler.join().expect("handler start failed");
}
```
### 2.2 Move
在一个从线程的闭包中，如果想使用主线程中接管某个变量的所有权，可以使用`move`关键字对闭包进行声明。
```rust
fn main() {
  let v = vec![1,2,3];
  let handler = thread::spawn(move || {
	println!(vec)
  });
  //v被转移给了handler的闭包中，不能再使用
  for i in 1..10 {
    println!("hello {i} from main");
  }
  handler.join().expect("handler start failed");
}
```
==move 闭包中如果有引用类型变量&x，那么 x 的生命周期就必须是静态的。因为编译器无法保证线程运行期间x是否存活==
## 2 线程通信

### 2.1 通道channel
线程之间通过互相发送消息来进行通信。rust标准库提供了channel来实现发送消息。
一个channel必须有两端。一端负责发送另一端接收。当其中一端停止运行后channel就会关闭。
channel方法返回一个元组，元组的第一个元素为发送端，第二个为接收端。
```rust
use std::sync::mpsc;
use std::thread;

fn main() {
  let (tx, rx) = mpsc::channel();
  let handler = thread::spawn(|| {
    let val = String::from("hello");
    tx.send(val).expect("send failed");
  })
  let message = rx.recv().expect("received failed");
  println!("get message: {message}");
}
```
发送端使用`send`方法来发送，这个方法的参数泛型是：`T: Send+'static`。普通的引用类型不满足这个要求。因此一般只能发送拥有所有权的变量或静态生命周期数据。并且send方法会消耗掉变量所有权。
==channel 的发送端（`tx`）所发送的所有消息必须都是同一种类型。==
接收端可以用`recv`和`try_recv`两种方法来接收消息。
revc会阻塞线程，直到接收到消息。消息会被包裹为Result。当所以发送端都关闭时，recv会返回一个Result的Err变体，表示通道已关闭。
try_recv不会阻塞线程，而是立即返回一个Result。如果有消息则是包裹消息的Ok变体，没有则是Err变体。
一个channel可以有多个发送端。但只能有一个接收端。可以对tx使用clone在一个channel中创建多个发送端。
发送端不能一次性发送多条消息，只能多次调用。rx实现了`IteratorInto`，可以通过for循环遍历所有收到的消息。