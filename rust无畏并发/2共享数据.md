通道是单一所有权的。即一块数据内存只能由一个线程来管理。
为了使多个线程能共享数据，需要对一个数据赋予多重所有权。
Rc和RefCell虽然可以实现多次共享数据，但是编译器无法保证这两种结构在多线程中的安全性（引用计数无法被正确计算），因此不能被用于多线程中。
## 1 互斥锁Mutex
互斥锁是解决竞态问题的。在同一时间内只允许一个线程访问数据。线程请求访问前必须先激活互斥锁的锁。同时在访问完成后必须解锁。
使用`Mutex`中的数据必须通过`MutexGuard`守卫，MutexGuard是一个智能指针，守卫的数据存储在heap上。
```rust
use std::sync::mutex;
fn main () {
  let m = Mutex::new(5);
  {
    let num = m.lock().unwrap(); //num是一个MutexGuard<i32>，需要解引用才能操作
    *num += 1;
  }
  //MutexGuard会在离开作用域时自动解锁，无需手动解锁
  println!("{m}"); //m中包含的数据为5
}
```
Mutex可以被转移所有权。但是一次只能移动到一个线程中，并且很有可能在线程的闭包结束时被释放。
注意`Mutex<T>`解锁后得到的`MutexGuard<T>`是一个智能指针。如果T是Vec等类型，解锁后得到的是指向T的智能指针，可以调用push等引用方法，因为MutexGuard实现了Deref，会进行自动解引用转换。而如果T是i32等copy类型，则需要手动解引用。
==Mutex及引用无法被直接用于多线程==。因为，`Mutex<T>`和`&Mutex<T>`的生命周期在多线程之间完全无法保证（拥有Mutex的线程可能比其他线程更早结束），所以一般无法直接用于多线程。
## 2 `Arc<T>`原子引用计数
`Arc<T>`是专为多线程设计的引用计数智能指针。损失了一部分性能换取线程安全性。类似于`RefCell<T>`也有内部可变性。用法类似`Rc`，需要对&self进行clone再使用。
通常使用`Arc<Mutex<T>>`来在多线程间共享数据。
`Arc<T>`**通常只用于拥有所有权的数据以及静态生命周期数据，不用于包裹引用类型&T**，因为无法保证引用的生命周期在线程间存活。
```rust
use std::sync::Mutex;
use std::thread;
use std::sync::Arc;

fn main {
  let counter = Arc::new(Mutex::new(0));
  let mut handles = vec![];
  
  for i in 1..10 {
    //10个线程轮流访问counter并进行修改  
    let counter = Arc::clone(&counter);
    let handle = thread::spawn(move || {
      let mut num = counter.lock().unwrap();
      *num +1;
    })
    handle.join().unwrap();
    handles.push(handle);
  }
  println("result: {}", *counter.lock.unwrap()); //10
}
```
Arc不直接提供可变引用，需要配合Mutex或者RwLock等提供内部可变性的类型使用。
## 3 Send与Sync
send和sync是实现线程间通信的核心概念。他们都属于Marker trait（无需实现任何方法的trait）
### 3.1 Send
实现了Send trait的类型可以在线程之间转移所有权。绝大部分rust类型都实现了Send，除了`Rc`和`RefCell`以及原始指针。如果一个结构体完全由满足Send的类型组成，那么也会自动实现Send。
### 3.2 Sync
实现了Sync trait的类型T可以安全地从多线程中使用这个类型的引用&T。
如果一个类型T的&T是Send，那么T就是Sync。Sync是Rust中保证线程安全的主要载体。
除之指针外的大多数数据类型都实现了Send和Sync。
注意：虽然大部分类型实现了Send和Sync，但其引用类型却无法发送给其他线程，因为非静态生命周期的引用类型生命周期太短，编译器无法保证存活。解决方法：
1.  使用 `thread::scope`
```rust
let s = String::from("Hello"); 
let s_ref = &s; 
// ✅ 使用 thread::scope，编译通过！ 
thread::scope(|scope| { 
	scope.spawn(|| { 
		println!("{}", s_ref); // 安全！s 的生命周期覆盖了整个 scope 
	}); 
	scope.spawn(|| { 
		println!("Length: {}", s_ref.len()); 
	}); 
}); // 所有子线程在此处 join 完毕后，s 才会被销毁
```
2.  将所有权转移（使用 `Arc`）
3. 使用static声明静态生命周期
```rust
static mut NUMBER: i32 = 20;
fn main() {
	thread::spawn(|| {
		NUMBER += 1;
	}).join().unwrap();
}
```
常见指针：
`Box<T>`由T决定是否是Send或Sync。
`Rc<T>`既不是Send也不是Sync。
`RefCell<T>`是否是Send由T决定，但不是Sync。
`Mutex<T>`是Send也是Sync，是多线程安全的，但是单独的Mutex不能用于多线程，必须与`Arc<Mutex>`配合。
`MutexGuard<T>`是否是Sync由T决定，但不是Send。
`Arc<T>`只有当T同时是Sync+Send是，才是Sync+Send