## 4.1 Join执行
Future有一个关联类型Output，用于表示Future的返回值。一个async块如果没有返回值那么这个async块返回的Future类型默认为：`Future<Output=()>`。
可以使用join处理多个的Future，直到Future全部执行完毕。
同时执行动态数量的Future组成的vec，可以使用trpl的join_all方法，但是要求这些Future的Output关联类型相同且不能为单元类型。
可以使这些Future被Pin住（设置为pin类型）并转化为trait object。即
`<Pin<Box<dyn Future<Output=()>>>>`
```rust
let fut1: <Pin<Box<dyn Future<Output=()>>>> = Box::Pin::new(async {
  //具体异步实现
});
let fut2: <Pin<Box<dyn Future<Output=()>>>> = Box::Pin::new(async {
  //具体异步实现
});
let fut_vec = vec![fut1, fut2];
trpl::join_all(fut_vec);
```
## 4.2 `Pin`指针
Box::pin是一种特殊的Box智能指针，类型是`Pin<Box<T>>`。而Pin本身是一个指针的包装器。保证了被包裹的指针指向的地址不会被move。常用于存在自身引用的结构体中。
最常见的用处是用于自定义实现Future trait。
为什么要pin：
因为async块本质上是一个状态机的结构体，状态机中包含了记录await点的状态的字段。其内部存在自引用（状态字段指向内部其他字段），一旦结构体被移动，那么其内部的自引用就会变成悬垂指针。
将Future存储在vec中，主要有两种方式：
1 使用`Box::pin`对Future进行包裹，得到一个`Pin<Box<dyn Future<Output=T>>>`，位于堆上。
2 使用`pin!`宏对async执行，得到一个`Pin<&mut dyn Future<Output=T>>>`。注意pin!宏返回的是一个固定位置的引用，位于栈上。
## 4.3 Trait Object
通常通过引用类型或智能指针，加上dyn关键字，在指定trait名称的方式来显式声明trait对象。
4.2所说的`&mut dyn Future<Output=T>`或者`Box<dyn Future<Output=T>>`就是一个trait object。
## 4.4 Race执行
使用race可以让多个Future同时执行，但所有Future会在最早结束的Future执行结束后同时结束。
```rust
trpl::run(async {
  let slow = async {
    println!("slow start");
    trpl::sleep(Duration::from_millis(200)).await;
    println!("slow finish");
  };
  let fast = async {
    println!("fast start");
    trpl::sleep(Duration::from_millis(100)).await;
    println!("fast finish");
  };
  trpl::race(slow, fast).await
});
//只会打印出slow start、fast start、fast finish。因为fast先结束
```
## 4.5 手动控制线程
如果一个Future中执行了一个需要长时间运行的程序，可能需要我们手动将线程交还给异步运行时来保证其他Future也能执行。我们可以在其中穿插一些`sleep.await`来进行这一操作。但更好的办法是使用`trpl::yield_now().await`，这是专用于交还线程给异步运行时的方法。
