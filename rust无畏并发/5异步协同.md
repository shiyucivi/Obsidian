### 1 Join执行
Future有一个关联类型Output，用于表示Future的返回值。一个async块如果没有返回值那么这个async块返回的Future类型默认为：`Future<Output=()>`。
可以使用join处理多个的Future，直到Future全部执行完毕。
同时执行动态数量的Future组成的vec，可以使用trpl的join_all方法，但是要求这些Future的Output关联类型相同且不能为单元类型。
可以使这些Future被Pin住（设置为pin类型）并转化为trait object。即
`<Pin<Box<dyn Future<Output=()>>>>`
```rust
let fut1: <Pin<Box<dyn Future<Output=()>>>> = Box::Pin::new(async {
  //具体异步实现
});
let fut2: <Pin<Box<dyn Future<Output=()>>>> = Box::Pin::new(async {
  //具体异步实现
});
let fut_vec = vec![fut1, fut2];
trpl::join_all(fut_vec);
```
### 2 Race执行
使用race可以让多个Future同时执行，但所有Future会在最早结束的Future执行结束后同时结束。
```rust
trpl::run(async {
  let slow = async {
    println!("slow start");
    trpl::sleep(Duration::from_millis(200)).await;
    println!("slow finish");
  };
  let fast = async {
    println!("fast start");
    trpl::sleep(Duration::from_millis(100)).await;
    println!("fast finish");
  };
  trpl::race(slow, fast).await
});
//只会打印出slow start、fast start、fast finish。因为fast先结束
```
### 3 手动控制线程
如果一个Future中执行了一个需要长时间运行的程序，可能需要我们手动将线程交还给异步运行时来保证其他Future也能执行。我们可以在其中穿插一些`sleep.await`来进行这一操作。但更好的办法是使用`trpl::yield_now().await`，这是专用于交还线程给异步运行时的方法。
