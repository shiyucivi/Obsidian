并行是指多个任务同时进行（多个人各自负责各自任务）。并发是指多个任务在一个CPU物理核上运行（一个人同时负责多个工作）。并发是并行的父集，并行是并发的高级方式。
多进程、多线程和异步是实现并发的不同机制。
异步使得一个线程可以同时执行多个异步任务。每当遇到异步等待时，将线程控制权转移到另一个任务中。异步等待完成后再等待拿回控制权。
异步并发主要解决IO密集型任务，多线程主要解决CPU密集型任务。

rust中的异步是需要运行时的。运行时用于协调并发任务对线程的控制权。
## 1 Future Async await
Future是实现了Future trait的类型，类似于Promise。用于保存一个目前没用但未来会存在的数据。
async用于声明一个代码块或函数，表面这个函数中存在会中断执行的异步以及未来重新恢复执行。
await用于记录暂停和恢复执行的节点。rust中使用轮询检查Future是否可用，一旦可用就从这个节点恢复执行。
==.await关键字的左边必须是Future类型的数据或表达式（async函数本身也是一个Future）。await的作用是解包Future中返回的具体数据==。
如果一个Future表达式后面没用.await，那么这个future中执行的操作是不会主动执行的。一个await操作表达式也必然是一个Future，可以多个await链式调用。
```rust
use trpl::Html;
//获取一个html的title标签内的字符串
async fn page_title(url: &str) -> Option<String> {
  //http get异步请求操作
  let response = trpl::get(url).await;
  //异步操作：将返回的http报文解析为字符串
  let response_text: String = response.text().await;
  //解析字符串并获取第一个title标签内的字符串
  Html::parse(response_text)
    .select_first("title") //返回的是Option<Element>类型
    .map(|title_element| title_element.inner_html())
}
```
==一个async函数或代码块的返回值必然是Future==。虽然上面的函数声明了返回值为`Option<String>`，但是异步运行时会将其转换为返回Future的函数：
```rust
//返回一个Future类型，其关联类型为Option<String>。
//同时隐式声明了一个生命周期'_，表示Future的生命周期与输入的url参数的生命周期绑定。因为异步函数的回调时机不确定，必须保证其依赖的引用在此期间存活。
fn page_title(url: &str) -> Future<Output = Option<String>> + '_ {
  async move {
    let text = trpl::get(url).await.text().await;
    Html::parse(&text).select_first("title")
      .map(|title_element| title_element.inner_html())
  }
}
```
这个async块使用了move，捕获的作用域会发生转移所有权。
==注意：async函数或async块返回的是future，调用async函数是不会直接运行的。如果想通过调用函数直接运行函数中的异步代码，不要给函数声明async！==
## 2 异步运行时
rust默认不提供异步运行时，因为rust无法保证其执行环境。
main函数中无法直接执行async。必须借助其他异步运行时：
```rust
use trpl::run;
fn main() {
    let args: Vec<String> = std::env::args().collect();
    run(async {
        let title = parse_html::page_title(&args[1]).await;
        match title {
            Some(text) => print!("{text}"),
            None => println!("{} no title found", &args[1])
        }
    })
}
```
这段代码中使用了trpl提供的异步运行时。
对于多个async执行块，可以使用异步运行时提供的方法来协调这些异步操作。例如`trpl::race`可以让两个future或async竞争执行，谁先执行完成就用它的返回值作为结果：
```rust
use trpl::{run, Either};
run(async {
  let title_future_1 = parse_html::page_title(&args[1]);
  let title_future_2 = parse_html::page_title(&args[2]);
  //race会让两个future竞争执行，返回一个Either枚举，Either::Left包裹第一个future返回的结果，Either::Left包裹第二个
  let unknow_title=
     match trpl::race(title_future_1, title_future_2).await {
       Either::Left(left) => left,
       Either::Right(right) => right
     };
   match unknow_title {
     Some(title) => println!("first title is {}", &title),
     None => println!("{} no title found", &url)
   }    
 })
```
注意：异步运行时不能嵌套
像tokio提供的`race`、`join`等宏，默认提供了异步运行时，不需要也不应该再在异步运行时中运行。
## 3 异步并发
trpl库提供了spawn_task来创建一个异步任务。这个异步任务类似于多线程，都并发地执行多个任务。但是与多线程有较大区别：
1 调度者不同：线程由操作系统调度，执行过程具有随机性。异步任务由异步运行时调度，每当遇到Future时才会切换其他任务。
2 线程开销比异步任务大很多。通常多线程用于CPU密集型并发任务，异步用于IO密集型并发任务。
一个异步任务也必须在一个异步运行时中创建。
```rust
use trpl
fn main() {
  trpl::run(
    async {
      //异步任务
      trpl::spawn_task(async {
        for i in 1..10 {
          println!("{i} from first task");
          trpl::sleep(Duration::from_millis(500)).await;
        }
      });
      //主异步任务
      for i in 1..5 {
        println!("{i} from second task");
        trpl::sleep(Duration::from_millis(500)).await;
      }
    }
  );
}
// 只会执行到5 from first task。因为主异步任务执行完成后程序直接退出而不会等待其他异步任务。
```
如果不想主异步任务结束时程序退出，需要对异步任务的句柄也进行.await操作，并且异步任务返回的是Option，需要手动处理：
```rust
let handler = trpl::spawn_task(async {
  for i in 1..10 {
    println!("{i} from first task");
	trpl::sleep(Duration::from_millis(500)).await;
  }
});
handler.await.unwrap();
```

一个异步任务与一个async块的区别：
一个async块是一个Future类型的表达式，不会主动执行。只有当它被 `.await` 或由执行器（如 `tokio::spawn`）调度时才会运行，并且async块可以使用闭包的方式捕获作用域（按照最小权限原则）。异步任务通常是指 **已经被调度到异步运行时（如 Tokio、async-std）中并发执行的 Future**。
一个异步运行时内部的async块是异步的，但是对于运行时所在的外部程序而言异步运行时是同步执行的，外部程序会等待异步运行时中的任务完成。
### 3.2 异步任务的所有权
使用`trpl::spawn_task`或者`tokio::spawn_task`创建的异步任务，其生命周期可能超出当前作用域。因此这些方法中的async块如果捕获外部作用域，只能捕获`'static`类型或move转移所有权方式来捕获。而普通的async块需要在其作用域内被await执行，生命周期不会超出当前作用域。
### 3.1 异步通信
trpl库也提供了channel用于异步任务之间的通信：
```rust
trpl::run(async {
  let (tx, mut rx) = trpl::channel();
  let vals = vec![
    String::from("hello"),
    String::from("from"),
    String::from("main"),
  ]
  // 使用move转移tx和val的所有权，确保tx发送完成后关闭
  let send_fut = async move {
    //这里的发送端是同步进行的(对于一些较复杂的发送程序可能是异步进行的)
    for val in vals {
      tx.send(val).unwrap();
      //间隔500ms
      trpl.sleep(Duration::from_millis(500)).await;
    }
  }
  let recv_fut = async move {
    while let Some(received) = rx.recv().await {
      println!("received: {received}");
    }
  }
  //让两个future并行执行，其中一个执行完成后另一个才能结束。
  trpl::join(send_fut, recv_fut).await;
})
```
不同于多线程的channel。异步channel的接收端不会阻塞当前任务，而是会异步地等待消息，收到后才开始执行。
可以对tx使用clone方法来创建多个发送。