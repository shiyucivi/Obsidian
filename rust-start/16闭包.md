在rust中，闭包就是匿名函数的同义词。只有闭包，才有捕获外部环境中变量的能力（这不代表闭包必须捕获外部环境）。
闭包的参数使用`||`包裹。rust会自动推断闭包的返回值类型（普通的fn声明函数需要手动声明返回值）
```rust
let closure_fn = |x: i32| x + 1; //rust推断closure_fn的返回值为i32类型
let s = closure_fn(33);
```
## 1 捕获引用或移动所有权
rust编译器会推断闭包中捕获外部环境中变量的方式，以最小权限为原则。从而尽量减少对外部环境中变量造成的影响。
闭包的捕获实际发生在调用时。但是！**即使你只定义闭包而不调用它，Rust 的借用检查器也判断已经发生捕获**。
### 1.1 捕获不可变引用
```rust
let list = vec![1, 2, 3];
let closure_fn = || println!("{list:?}");
closure_fn();
//捕获只发生在调用时，闭包对list的可变引用结束
println!("{list:?}"); //list没用被释放仍然可以读取
```
这个例子中闭包捕获了外部环境的list变量的只读引用。执行闭包时不会影响list变量的读取。
### 1.2 捕获可变引用
```rust
let mut list = vec![1, 2, 3];
let mutborrow_closure = || { list.push(7) };
println!("{list:?}"); //❌，此时已经发生了可变引用
mutborrow_closure();
```
这个例子中闭包捕获了外部的list的可变引用。rust编译器会检查从闭包定义到调用之间的语句，确保中间没用其他引用。
### 1.3 捕获所有权
```rust
let list = vec![1, 2, 3];
let move_closure = move || println!("{list:?}");
move_closure();
//list已经被释放，不能再使用list
```
在闭包前加上move会声明闭包中的所有捕获都是捕获所有权。闭包执行结束后会释放其中的所有捕获。
## 2 闭包的trait
闭包可以实现三个trait：Fn（捕获不可变引用）、FnMut（捕获可变引用）、FnOnce（捕获所有权）。
如果闭包将捕获移出了其所在环境，那么只能实现FnOnce，也只能调用一次。
闭包不移出捕获，但可能修改捕获，可以调用多次。
闭包不移出或修改捕获，可以多次调用并且不会修改环境。特别适用于多线程并发调用的场景。
==注意，闭包的trait与是否是move闭包无关。只与闭包中对外部变量的处理逻辑有关。==
这三个trait是层层递进的关系，捕获越少的闭包要求越严格，Fn和FnMut都默认实现了FnOnce，而实现了Fn的闭包默认实现了FnMut。
## 2.1 闭包trait作为泛型的trait bounds
这些trait可以作为trait bounds来限制函数参数的泛型，例如Option枚举的unwrap_or_else方法：
```rust
impl <T> for Option<T> {
  pub fn unwrap_or_else<F> (self, f:F)
  where F: FnOnce() -> T {  //限制泛型F只能为符合FnOnce的闭包
    match self {
      Some(x) => x,
      None() => f(),
    }
  }
}
```
可变集合类型的sort_by_key方法也是使用闭包作为参数：
```rust
struct Rectangle {
  width: u32,
  height: u32,
}
let mut list = [
  Rectangle {width: 10, height: 20},
  Rectangle {width: 20, height: 10},
];
list.sort_by_key(|r| r.width); //按照width从小到大排序
```
sort_by_key的闭包参数是个FnMut。这个闭包不能获取外部环境变量的所有权（不能在其中调用会对外部环境产生所有权变化的函数和方法）。
**注意：闭包要使用哪种trait，与使用参数接收还是捕获外部变量无关，与对外部变量的处理方式有关。即使一个闭包只通过参数接收外部变量，那么只要在其中做出了修改，就至少要满足FnMut**

