泛型用于指定一些调用时才知道具体类型的变量的类型。
## 1 函数泛型
```rust
fn largest<T>(list: &[T]) -> &T {
  let mut largest: &T = &list[0];
  for item in list {
    if (item > largest) { //会报错，泛型T不一定实现了比较的trait
      largest = item;
    }
  }
}
```
## 2 结构体泛型
```rust
struct Point<T,U>{
  x: T,
  y: U 
}
```
## 3 枚举泛型
```rust
enum Colors<T> {
  Red(T),
  green(T)
} 
```
## 4 方法泛型
### 4.1 整个结构体的方法实现泛型
如果是为整个结构体（而非结构体的某个具体泛型），`impl` 后面的泛型参数必须与结构体定义时的泛型参数在“形式”上一致
```rust
struct Point<T, U> {
  x:T,
  y:U
}
impl <T, U> Point <T, U> {
  fn get_x(&self) -> T {
    &self.x
  }
}
```
### 4.2 单一方法的泛型

```rust
struct Logger;
impl Logger {
    // 方法有自己的泛型 U，对U进行了约束，必须实现Display trait
    fn log<U: std::fmt::Display>(message: U) {
        println!("Log: {}", message);
    }
}
```
### 4.3 指定具体类型
具体类型的方法名称不能与整个结构体方法名称重复
```rust
struct Point<T> {
  x:T,
  y:U
}
impl Point<f32> {
  fn distance_from_origin(&self) -> f32 {
    (self.x.powi(2) + self.y.powi(2)).sqrt
  }
}
impl<T> Point<T> {
  fn distance_from_origin(&self) -> T {
  }
}
//❌，Point整体不能再定义distance_from_origin同名方法
```
### 4.3 方法重载
可以针对结构体的不同泛型实现同一方法名称的不同实现，只要不与整个结构体的方法重名：
```rust
struct Point<T> {
  x:T,
  y:U
}
impl Point<f32> {
  fn distance_from_origin(&self) -> f32 {
    (self.x.powi(2) + self.y.powi(2)).sqrt
  }
}
impl Point<i32> {
  fn distance_from_origin(&self) -> f32 {
    //具体实现
  }
}
impl <T:std::ops::AddAssign> Point<T> {
  fn add_vector(&mut self, other: Point<T>) {
    self.x += other.x;
    self.y += other.y;
  }
}
```