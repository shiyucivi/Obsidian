## 1 `From<T>`和`Into<T>` trait
From是标准库中用于安全地进行类型转换的trait。提供了一个from方法的签名。但没有具体实现。
```rust
pub trait From<T> {
  fn from(T) -> Self;
}
// 泛型参数T必须是具体类型或trait约束
impl From<String> for U {
  fn from(String) -> Self {
    //具体实现
  }
}
// 将泛型T转化为已实现的结构体类型U
```
错误转换最常用的场景是将标准库中的错误类型转为自己需要的错误类型
```rust
use std::fs;
use std::io;
use std::num::ParseIntError;
enum MyError {
  Io(io::Error),
  ParseInt(ParseIntError),
  Other(String)
}
//将io:Error类型转为MyError::Io类型
impl From<io::Error> for MyError {
  fn from(value: io::Error) -> Self {
    MyError::Io(value)
  }
}

fn read_file() -> Result<String, MyError> {
  let content = fs::read_to_string("file.txt")?; //?会根据函数签名，自动调用MyError::from将io::Error转为MyError
  Ok(content)
}
```
如果一个结构体U实现了`From<T> trait`，会默认对T实现了返回U的Into方法，但实现了Into不会自动实现From trait：
```rust
struct Wrapper(i32);
impl From<i32> for Wrapper {
    fn from(value: i32) -> Self {
        Wrapper(value)
    }
}
fn main() {
    let w: Wrapper = 42.into(); // 自动调用 From<i32> 的实现
    println!("{}", w.0); // 输出 42
}
```
在上面的错误转换例子中：
```rust
fn ioerror_into_myerror {
  let content: Result<String, io::Error> = fs::read_to_string("file.txt");
  match content {
	Ok(content) => Ok(content),
	Err(error) => Err(error.into()) //error类型为io::Error，into返回MyError类型
  }
}
```
==?操作符会自动地将?表达式的错误类型转换为返回值注解要求的错误类型==
### 2 `TryFrom<T>`和`TryInto<T>` trait
对From trait进行实现时，必须是成功的实现。否则应该使用`TryFrom<T>`和`TryInto<T>`。
try_from和try_into方法返回一个Result。
例如将一个i32数字转为u8数字：
```rust
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}
enum IntoColorError {
    BadLen,
    IntConversion
}
impl TryFrom<(i16, i16, i16)> for Color {
    type Error = IntoColorError;
    fn try_from(tuple: (i16, i16, i16)) -> Result<Self, Self::Error> {
        let (red, green, blue) = tuple;
        let range = 0..=255;
        if range.contains(&red)&&range.contains(&blue)&&range.contains(&green){
            Ok(Color {
                red: red.try_into().unwrap(),
                green: green.try_into().unwrap(),
                blue: blue.try_into().unwrap()
            })
        } else {
            Err(IntoColorError::IntConversion)
        }
    }
}
```
### 3 As操作符
`as` 操作符和 `into()` 方法（通常通过 `Into` trait 使用）都可用于类型转换，但as操作符是系统内置的语法，只能用于基础数据类型（数字、bool、指针等），不能用于复合数据类型。
```rust
let x: i32 = 1000; 
let y: u8 = x as u8; // 静默截断！y = 232 (1000 % 256)
```
### 4 `Result::Err`和`Error` trait
`Result<T, E>`的`E`错误类型泛型不要求必须实现`std::error::Error` trait。但是为了方便调试，尽量为`E`实现`Error` trait。
#### 4.1 自定义错误类型
大多数错误类型都基于`std::error::Error` trait进行实现。这个trait实现了Debug和Dislay trait，因此要先实现这两个trait。
```rust
use std::fmt; 
use std::io; 
use std::num::ParseIntError; 
//自动实现debug
#[derive(Debug)] 
pub enum ConfigError {
	//包含三种错误类型，前两个错误类型是封装其他库的错误，第三个是独创的错误类型
	Io(io::Error), 
	InvalidPort { 
		line: String, 
		source: ParseIntError 
	}, 
	InvalidFormat(String)
}
//实现Display， write宏用来将报错的字符串转化为rust的标准字符串方便打印
impl fmt::Display for ConfigError {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { 
		match self { 
			ConfigError::Io(e) => write!(f, "I/O 错误: {}", e), 
			ConfigError::InvalidPort { line, .. } => {
				write!(f, "端口解析失败：'{}' 不是有效数字", line) 
			},
			ConfigError::InvalidFormat(line) => { 
				write!(f, "格式错误：无法解析行 '{}'", line) 
			} 
		} 
	}
}
// 实现Error trait
// 务必实现source方法。这个方法需要将内部封装的错误类型包裹为Option返回。使得发生这个错误时能沿着错误链追踪到更底层的错误。
impl std::error::Error for ConfigError { 
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> { 
		match self { 
			ConfigError::Io(e) => Some(e), 
			ConfigError::InvalidPort { source, .. } => Some(source), 
			ConfigError::InvalidFormat(_) => None, 
		} 
	} 
}
//可选：实现到io::Error的错误类型转换，如果函数声明返回值result的错误类型为io::Error，如果?前面的表达式返回错误类型为ConfigError，那么会自动转化为io::Error
impl From<io::Error> for ConfigError { 
	fn from(e: io::Error) -> Self { 
		ConfigError::Io(e) 
	} 
}
```
### 5 归一化错误类型
常用的错误类型归一化手段包括：
- 利用`Form` trait和`Error` trait实现自定义错误枚举类型
- 利用`Result<T, Box<dyn Error>>`动态错误类型，这是最方便快捷的手段
#### 5.1 `thiserror` crate
`thiserror`提供了自定义的错误类型与标准库中的错误类型实现互相转化的宏：
```rust
#[derive(thiserror::Error, Debug)] 
enum MyError { 
	#[error("Environment variable not found")]
	EnvironmentVariableNotFound(#[from] std::env::VarError), 
	#[error(transparent)]
	IOError(#[from] std::io::Error),
}
use std::fs::read_to_string;
fn render() -> Result<String, MyError> { 
	let file = std::env::var("MARKDOWN")?; 
	let source = read_to_string(file)?; 
	Ok(source) 
}
```
#### 5.2 `anyhow` crate
anyhow提供了一个归一化的`anyhow::Result`类型，大多数错误类型均可转换为`anyhow::Result`。可以直接在函数中使用。