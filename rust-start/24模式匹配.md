## 1 match分支
```rust
match x {
  Some(val) -> val,
  None -> None
}
```
## 2 if let =
用于处理某个单独的匹配分支
```rust
let a: Option<&str> = None;
if let Some(val) = a {
  println!("{val}");
}
```
## 3 while let = 
用于处理一系列的匹配：
```rust
let (tx, rx) = std::sync::mpsc::channel();
std::thread::spawn(move || {
  for val in 1..3 {
    tx.send(val).unwrap();
  }
})
while let Some(val) = rx.recv() {
  println!("{val}");
}
```
## 4 for()
```rust
let v = vec!["a", "b", "c"];
for (i, val) in v.iter().enumerate() {
  println!("index {i} is {val}");
}
```
## 5 解构赋值
```rust
let (x, y, z) = (1, 2, 3);
```
## 6 可反驳性
如果一个模式匹配中会出现匹配不上的情况，那么这个匹配就是可反驳的。
match是不可反驳的，因为match会匹配所有情况，不会出现不比配的情况。
而`if let`、`while let`等是可反驳的。

## 7 match的多种用法
match提供了多种灵活写法用来更方便的进行匹配：
### 7.1 字面量匹配
最常见的匹配方式
```rust
let x = "a";
match x {
  "a" => println!("a"),
  _ => {}
}
```
## 7.2 多模式匹配与范围匹配
```rust
let x = 1;
match x {
  1 | 2 => println!("one or two"),
  3 => println!("three"),
  4..10 => println!("range fout to ten"),
  _ => {}
}
```
### 7.3 同时匹配多个变量
```rust
let mut val1 = Some(5);
let val2 = Some(10);
match (val1, val2) {
  (Some(value1), Some(value2)) => {
    value1 += value2
  },
  _ => {
    val1 = val2
  }
}
```
### 7.4 匹配守卫
在匹配条件后增加一个if，可以对匹配项做出进一步的限制
```rust
let num = Some(4);
match num {
  Some(x) if x%2 == 0 => println!("number is even"),
  Some(x) => println("number is odd"),
  None => {},
}
```
## 8 赋值解构

## 9 绑定赋值
