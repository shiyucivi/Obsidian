## 1 panic!宏
```rust
panic!("failed")
```
panic会默认展开stack并清理数据。可以在toml中配置panic执行后直接终止程序，由操作系统接管内存。
## 2 Result枚举
result枚举通常用于描述一个操作的执行结果。result有两个枚举值：`Ok<T>`和Err。
```rust
// 读取一个txt文件
use std::fs::File;
let file_result: Result<File> = File::Open("hello.txt"); //读取文件所在目录下的hello.txt文本
```
 rust强制要求必须对Result进行进一步处理。通常有两种处理方式
### 2.1 match result
```rust
let file_text = match file_result {
  Ok(file) => file,
  Err(error) => panic!("Read file failed: {error:?}")
}
```
`{:?}`和`{}`是两种不同的打印方式。`{:?}`要求结构体实现Debug trait就可以实现打印。而普通的`{}`打印要求实现Display trait。
### 2.2 expect和unwrap
可以使用expect和unwrap快速处理Result。两个方法都会在Result为Err时panic并打印自定义的消息。在Ok时返回成功操作结果中的数据。
```rust
let file_result = File::Open("hello.txt").expect("File not found!");
```
### 2.3 ?运算符
可以在一个Result后面直接跟一个?运算符。当Result为Ok时会解包Ok并执行下一个语句，为Err时强制函数返回Err中的错误。
==使用?运算符的函数，其返回值类型必须为`Result<T, E>`或`Option<T>`类型==
```rust
fn read_file_and_write_str() -> Result<File, io:Error> {
  let file_result = File::Open("hello.txt")?;
  let text = String::new();
  file_result.read_to_String(&mut text)?;
  Ok(text)
}
// 注意这个函数的Result的Error泛型为io:Error
```
### 2.4`Box<dyn Error>`
main函数可以返回实现了`std::process:Termination` Trait的类型。代表就是动态错误类型`Box<dyn Error>`。
## 3 Result与Option区别
result通常用于描述对于外界的某种操作（文件读取、IO、网络请求等）的结果，而option则是程序内部对某个结构体操作（对字段、索引等的读取等）的结果。
result和option都可以使用unwrap和expect这两个快捷处理方法。
### 3.1 Result与Option都返回的情况
可以使用 `Result<Option<T>, E>`嵌套类型。但为了统一语义，最好再对函数中返回Option的语句进行进一步处理，来返回Result类型。
如果在函数中，既使用Option?，又使用Result?，那么只能声明返回类型为 `Result<Option<T>, E>`。但为了函数语义清晰，最好不要这么做。