### 1 panic!宏
```rust
panic!("failed")
```
panic会默认展开stack并清理数据。可以在toml中配置panic执行后直接终止程序，由操作系统接管内存。
### 2 Result枚举
result枚举通常用于描述一个操作的执行结果。result有两个枚举值：`Ok<T>`和Err。
```rust
// 读取一个txt文件
use std::fs::File;
let file_result: Result<File> = File::Open("hello.txt"); //读取文件所在目录下的hello.txt文本
```
 rust强制要求必须对Result进行进一步处理。通常有两种处理方式
#### 2.1 match result
```rust
let file_text = match file_result {
  Ok(file) => file,
  Err(error) => panic!("Read file failed: {error:?}")
}
```
`{:?}`和`{}`是两种不同的打印方式。`{:?}`要求结构体实现Debug trait就可以实现打印。而普通的`{}`打印要求实现Display trait。
#### 2.2 expect和unwrap
可以使用expect和unwrap快速处理Result。两个方法都会在Result为Err时panic并打印自定义的消息。在Ok时返回成功操作结果中的数据。
```rust
let file_result = File::Open("hello.txt").expect("File not found!");
```
类似的还有`expect_or`和`unwrap_or`方法，用于在结果为Err或None时提供默认值。
#### 2.3 ?运算符
可以在一个Result后面直接跟一个?运算符。当Result为Ok时会解包Ok并执行下一个语句，为Err时强制函数返回Err中的错误。
==使用?运算符的函数，其返回值类型必须为`Result<T, E>`或`Option<T>`类型==
```rust
fn read_file_and_write_str() -> Result<File, io:Error> {
  let file_result = File::Open("hello.txt")?;
  let text = String::new();
  file_result.read_to_String(&mut text)?;
  Ok(text)
}
// 注意这个函数的Result的Error泛型为io:Error
```
### 3 Result与Option区别
result通常用于描述对于外界的某种操作（文件读取、IO、网络请求等）的结果，而option则是程序内部对某个结构体操作（对字段、索引等的读取等）的结果。
result和option都可以使用unwrap、expect、?操作符等快捷处理方法。
#### 3.1 Result与Option都返回的情况
Result和Option都支持?操作符，但是不能在函数中同时对两种类型都使用?。可以使用组合器将其进一步转换为同一类型。
### 4 组合器
rust提供了多种组合器以便对Result和Option进行转换或进一步处理
#### 4.1 `or`和`and`
用于将两个Result或Option进行逻辑与和逻辑或处理。
- `or()`，表达式按照顺序求值，若任何一个表达式的结果是 `Some` 或 `Ok`，则该值会立刻返回
- `and()`，若两个表达式的结果都是 `Some` 或 `Ok`，则**第二个表达式中的值被返回**。若任何一个的结果是 `None` 或 `Err` ，则立刻返回。
```rust
let o1: Result<&str, &str> = Ok("ok1");
let o2: Result<&str, &str> = Ok("ok2"); 
let e1: Result<&str, &str> = Err("error1"); 
let e2: Result<&str, &str> = Err("error2");
assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2
assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1
assert_eq!(e1.or(o1), o1); // Err or Ok = Ok 
assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2
```
#### 4.2 `or_else`和`and_then`
跟 `or()` 和 `and()` 类似，唯一的区别在于，它们的第二个表达式是一个返回`Option`或`Result`的闭包
```rust
let s1 = Some("some1"); 
let fn_none = || None;
assert_eq!(s1.or_else(fn_some), s1);
```
#### 4.3 filter
Option的filter方法用于对 `Option` 进行过滤，接收一个闭包作为参数，过滤的结果仍为Option。
```rust
let s1 = Some(3); 
let fn_is_even = |x: &i8| x % 2 == 0; 
assert_eq!(s1.filter(fn_is_even), n);
```
#### 4.4 map和map_err
map和map_err是最常用的对Option和Result进行转换与映射的方法。map用于对Option和Result的Ok变体进行处理（如果是Err变体则不会执行），map_err则只负责对Result的Err变体进行处理（其他变体不会执行）。
```rust
let character_count = |s: &str| s.chars().count();
let s1 = Some("abcde"); 
assert_eq!(s1.map(character_count), Some(5));
let n1: Option<&str> = None; 
let n2: Option<usize> = None;
assert_eq!(n1.map(character_count), n2);
let o1: Result<&str, &str> = Ok("abcde");
assert_eq!(o1.map(character_count), Ok(5));

let e1: Result<&str, &str> = Err("404"); 
let e2: Result<&str, isize> = Err(404);
assert_eq!(e1.map_err(|s: &str| -> isize { s.parse().unwrap() }), e2);
```
#### 4.5 ok、ok_or和ok_or_else
ok方法用于将Result转为Option，`Ok<T>`转为`Some<T>`，Err转为None：
```rust
let res: Result<i32, &str> = Ok(42);
let opt: Option<i32> = res.ok();
assert_eq!(opt, Some(42));
```
ok_or和ok_or_else则是将Option转为Result，都是以Err类型作为参数，区别在于ok_or_else参数为闭包：
```rust
let s = Some("abcde");
let n: Option<&str> = None;
let fn_err_message = || "error message";
s.ok_or("error message"); //Ok("abcde")
n.ok_or(fn_err_messahe); //Err("error message")
```
### 5 main函数中使用`?`
main函数要求返回值必须满足Termination trait。
最简单的方法是将main函数的返回签名设置为：`Result<(), Box<dyn std::error::Error>>`。并在main函数的最后一行放置返回值`Ok(())`。
如果设置返回具体类型的Error，这个Error要满足Debug trait。
或者直接使用anyhow：
```rust
use anyhow::Result; 
use std::fs; 
fn main() -> Result<()> { 
	let content = fs::read_to_string("config.json")?; 
	println!("内容: {}", content); 
	Ok(()) 
}
```