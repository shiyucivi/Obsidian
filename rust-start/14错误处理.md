## 1 panic!宏
```rust
panic!("failed")
```
panic会默认展开stack并清理数据。可以在toml中配置panic执行后直接终止程序，由操作系统接管内存。
## 2 Result枚举
result枚举通常用于描述一个操作的执行结果。result有两个枚举值：`Ok<T>`和Err。
```rust
// 读取一个txt文件
use std::fs::File;
let file_result: Result<File> = File::Open("hello.txt"); //读取文件所在目录下的hello.txt文本
```
 rust强制要求必须对Result进行进一步处理。通常有两种处理方式
### 2.1 match result
```rust
let file_text = match file_result {
  Ok(file) => file,
  Err(error) => panic!("Read file failed: {error:?}")
}
```
`{:?}`和`{}`是两种不同的打印方式。`{:?}`要求结构体实现Debug trait就可以实现打印。而普通的`{}`打印要求实现Display trait。
### 2.2 expect和unwrap
可以使用expect和unwrap快速处理Result。两个方法都会在Result为Err时panic并打印自定义的消息。在Ok时返回成功操作结果中的数据。
```rust
let file_result = File::Open("hello.txt").expect("File not found!");
```
### 2.3 ?运算符
可以在一个Result后面直接跟一个?运算符。当Result为Ok时会解包Ok并执行下一个语句，为Err时强制函数返回Err中的错误。
==使用?运算符的函数，其返回值类型必须为`Result<T, E>`或`Option<T>`类型==
```rust
fn read_file_and_write_str() -> Result<File, io:Error> {
  let file_result = File::Open("hello.txt")?;
  let text = String::new();
  file_result.read_to_String(&mut text)?;
  Ok(text)
}
// 注意这个函数的Result的Error泛型为io:Error
```
### 2.4`Box<dyn Error>`
main函数一般不声明返回值类型，但可以返回实现了`std::process:Termination` Trait的类型。代表就是动态错误类型`Box<dyn Error>`。
## 3 Result与Option区别
result通常用于描述对于外界的某种操作（文件读取、IO、网络请求等）的结果，而option则是程序内部对某个结构体操作（对字段、索引等的读取等）的结果。
result和option都可以使用unwrap和expect这两个快捷处理方法。
### 3.1 Result与Option都返回的情况
可以使用 `Result<Option<T>, E>`嵌套类型。但为了统一语义，最好再对函数中返回Option的语句进行进一步处理，来返回Result类型。
如果在函数中，既使用Option?，又使用Result?，那么只能声明返回类型为 `Result<Option<T>, E>`。但为了函数语义清晰，最好不要这么做。

## 4 Option快速处理
如果不想使用match和unwrap，可以使用这些处理方式：
### 4.1 unwrap_or提供默认值
```rust
let config = get_config(); // 返回 Option<i32>
let port = config.unwrap_or(8080); // 若为 None，则用 8080
```
### 4.2 map
仅当为 `Some(x)` 时，将 `x` 映射为 `f(x)`，结果仍为 `Option<U>`。
```rust
let num = Some(5);
let doubled = num.map(|x| x * 2); // Some(10)
```
### 4.3 if let
只处理Some的情况
```rust
if let Some(value) = get_optional_value() {
    println!("Got: {}", value);
}
```
### 4.4 布尔判断辅助：`is_some()` / `is_none()`
```rust
if user_input.is_some() {
    process(user_input.unwrap()); // 此处 unwrap 安全（因已判断）
}
```
### 4.5 as_ref方法
对于`&Option<T>`类型，可以调用as_ref()方法将其转化为`Option<&T>`再解包。用于快速得到其内部包裹的引用。
### 4.6 take方法
take方法可以简单粗暴地从Option中取出值并转移所有权，取出后原Option会变为None。
```rust
let o = Some(5);
let o1 = o.take(); 
```
## 5 Result快速处理
### 5.1 expect
虽然 `expect()` 仍会 panic，但它提供可读性更强的错误信息
```rust
let file = File::open("config.toml").expect("Config file must exist!");
```
### 5.2 unwrap_or提供默认值
### 5.3 错误传播：`?` 运算符
最适合于生产
```rust
fn read_config() -> Result<String, io::Error> {
    let mut file = File::open("config.txt")?; // 若失败，立即 return Err
    let mut content = String::new();
    file.read_to_string(&mut content)?;
    Ok(content)
}
```