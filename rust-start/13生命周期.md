==编译器必须将一个引用类型与其引用的数据关联起来，生命周期就是用来关联的==
## 1 借用检查器
在rust中，每个变量都存在一个生命周期。如果其生命周期结束，但还有地方用到了这个引用，那么就会发生未定义错误：
```rust
let r;
{
  let x = 5;
  r = &x;
}
println!("{r}"); //❌ r是x的引用，但是x的声明周期已经结束，r超出了x生命周期
```
rust存在一个借用检查器制度。检查所有存在引用的变量的作用域。确保其生命周期长于它的引用。
## 1 生命周期泛型参数
```rust
fn longest(s1: &str, s2: &str) -> &str {
  if s1.len() > s2.len() { x }
  else { y }
}
let x = "hello";
let y = "lol";
let long_str = longest(x, y);
//❌ 参数和返回都是引用，因此返回值必然是s1或者s2，但编译器无法判断返回值long_str是x还是y 
```
参数是运行时才决定的，借用检查器在对函数进行检查时，因此只能从函数的类型签名中判断每个变量的声明周期。当函数中存在多个引用类型变量并且返回值也是引用类型变量时，无法判断引用类型的返回值是哪个引用类型变量，因此无法将返回值的生命周期与某个被引用的变量进行绑定。
生命周期泛型参数分为两种：输入生命周期（可能存在多个）和输出生命周期（只有一个）。相同泛型符号的输入与输出代表二者之间具有生命周期约束。
生命周期泛型用于描述多个引用之间的生命周期的关系，拥有泛型'a的返回值的生命周期==不会超过==具有相同泛型’a的引用类型变量的声明周期。借用检查器会对相同生命周期泛型的变量进行检查。
```rust
fn longest <'a> (&'a s1, &'a s2) -> &'a str {
  if s1.len() > s2.len() { x }
  else { y }
}  // 返回值的生命周期不会超过s1或s2
let s1 = "hello";
{
  let s2 = "something";
}
print("{longest(s1, s2)}");
//❌ 检查器发现longest返回值的生命周期超出了s2的生命周期
```
## 2 struct生命周期
如果一个struct的某个字段是引用类型。那么必须标注这个字段的生命周期。表面结构体生命周期不能超出引用类型字段的引用变量的生命周期。(结构体本身不能是引用类型，因此不存在这个问题)。
```rust
struct ImportantExcerpt <'a> {
  part: &'a str,
}
// part字段是一个引用类型，结构体ImportantExcerpt不能超出part字段的生命周期
let novel = "Long time ago, world is a ...";
let first_str = novel.split(,).next().unwrap();
let i = ImportantExcerpt {
  part: first_str
}
// i的生命周期不能超过novel
```
## 3 需要写生命周期的场景：
即使不标注生命周期，编译器会默认给每个参数一个单独的生命周期，那么以下场景中编译器能自动推断出输出生命周期，不需要显式声明生命周期：
1 函数只有一个引用类型参数和一个引用类型输出，那么只存在一个输入生命周期，自然也只有一个输出生命周期
```rust
fn foo(x: &str) -> &str {...}
//相当于
fn<'a> foo(x: &'a str) -> &'a str {...}
```
2 有多个生命周期参数，但存在参数&self或&mut self，输出生命周期必然等于&self的生命周期
```rust
struct ImportantExcerpt <'a> {
  part: &'a str,
}
impl ImportantExcerpt {
  fn level(&self, s: &str) -> &str {
    println!("{s}");
    self.part
  }
}
// 不需要声明声明周期
```
而当存在多个输入生命周期而不确定输出生命周期的情况下，必须声明生命周期参数：
因此可以判断出，以下场景必须标明生命周期：
1 多个引用类型参数和一个引用类型输出，编译器无法判断输出关联的是哪个参数的生命周期
2 函数的参数是引用类型结构体，并且结构体中存在引用类型字段，编译器也无法判断出输出关联的是结构体的生命周期还是结构体中的引用类型字段的生命周期：
```rust
struct ImportantExcerpt <'a> {
  part: &'a str,
}
fn foo<'a, 'b>(i: &'a ImportantExcerpt<'b>) -> &'a str {
  i.part
}
//'a是函数参数&ImportantExcerpt的生命周期，'b是ImportantExcerpt的part字段的结构体
// 其实这个例子中foo不需要声明声明周期，因为结构体的生命周期必然小于引用字段生命周期，而foo输出生命周期又必然小于输入结构体生命周期，即'a<'b，可以只保留'a，既然只有一个参数有'a，那么'a也可以省略
```
## 4 `'static`
#### 4.1 `'static`作为生命周期标注
`'static`表示一个静态生命周期，静态生命周期会长期存在，存活到整个程序结束。
字面量字符串默认具有`'static`生命周期
```rust
let s: &str = "hello";
//相当于
let s: &'static str = "hello";
```
#### 4.2 `'static`作为泛型约束
泛型约束中的`'static`和`'static`作为生命周期是完全不同的含义。`T: 'static`表示类型T不包含任何非`'static`的引用。也就是T满足两个条件中的一个：要么是自己拥有的数据（`owned`），如果包含引用的话必须`'static`引用。**满足`'static`约束的值不一定要存活到整个程序结束，只需要保证整个执行期间内存活**。
```rust
fn spawn_task<T: Send+ 'static>(task: T) {
	thread::spawn(move|| {
		//使用task
	})
}
let s = "hello".to_string(); //s是owned的
spawn_task(s);
```
