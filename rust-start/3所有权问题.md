🔹 **“读用 `&`，改用 `&mut`，交出去就别加。”**  
🔹 **“方法调用不用管，编译器自动办。”**  
🔹 **“Copy 类型随便传，非 Copy 要小心。”**

# 1 stack、heap和stackframe

在rust中，将变量根据内存所在划分两种为两种类型：标量类型（Copy类型）和复合类型。只有数字、浮点数、字符、布尔值属于标量类型，变量及数据本身都存储在stack中。其余复合类型均属于heap指针类型，数据存储在heap中，但变量为stack中的指针，指向数据所在的heap。

## 1.1 rust中的内存释放机制
rust在执行时，会根据每个作用域（可以理解为一个大括号{}内的所有语句）生成一个作用域块即stackframe。作用域中所有创建的变量会生成一个stack保存在这个stackframe中。
当作用域执行完毕，会释放掉这个作用域的stackframe中的stack。如果stack是个heap指针，那么同时也要释放掉指针指向的heap。

这样产生的问题：如果一个作用域A中的指针变量A1赋值给另一个作用域B中的变量B1，当B执行完毕会释放B1的stack及其heap，那么回到A执行时，变量A1就变成了指向不存在heap的悬垂指针。如果继续使用A1会产生无法预测的问题，就是rust中的未定义行为。（标量类型不存在heap因此不会出现这种问题。）

stack和heap最根本的区别在于，stack在所属stackframe结束后必被释放，而heap可能不释放。
# 2 所有权

为了避免两个变量同时指向一个heap所引发的冲突。rust使用所有权机制来规定一个heap的归属。例如：
```rust
let a = String::from("Hello");
let b = a;
```
创建变量a时，a变量拥有字符串Hello的heap的所有权。而a赋值给b时，是将字符串Hello的heap也转移给了b，这一过程被称为==所有权转移==。此时a的指针是个==被移动变量==（注意不是空指针，空指针是运行时概念，rust编译不允许出现空指针），不能被再次使用。
## 2.1 函数中的变量所有权
rust中函数在执行时，会创建一个函数作用域的stackframe，同时根据函数参数创建若干个stack，并将传入的变量的所有权转移给这些stack。这一过程中如果没有特殊声明也会发生所有权转移。函数作用域结束后参数的stack被释放。原先的变量不能再使用。
```rust
fn main() {
	let mut s = String::from("Hello");
	take_owner(s)
	println!("{s}") //报错，s已被释放
}
fn take_owner(s: String) {
	s.push_string("world")
}
```
# 3 克隆与借用
如果我们想在赋值时不转移所有权，有两种方式：克隆clone和借用borrow。
## 3.1 克隆
```rust
let a = String::from("hello");
let b = a.clone();
println!("{a}");  //仍然可以使用a
```
## 3.2 借用（引用）
借用也称引用，是指在新变量赋值旧变量时，stack指针不指向旧变量指针的heap，而是指向旧变量本身的stack，也就是==指向指针的指针==。这样销毁新变量时，旧变量不受影响。借用分为2种使用方法：
1 直接引用：
```rust
let a = String::from("Hello");
let b = &a;
```
2 函数参数引用：
```rust
fn main() {
	let s = String::from("Hello");
	borrow_string(&s);
	println!("{s}");
}
fn borrow_string(s: &String) {
	println!("{s}");
}
```
可变引用参数：
```rust
fn main() {
	let mut s = String::from("Hello");
	let s2 = mut_borrow_string(&mut s);
	println!("{s2}");
	//s2是指向s的stack的指针
}
fn mut_borrow_string(s: &mut String) {
	s.push_str("world");
}
```
使用可变引用作为参数的函数，传入的变量必须也是mut变量。
## 4 引用与解引用