🔹 **“读用 `&`，改用 `&mut`，交出去就别加。”**  
🔹 **“方法调用不用管，编译器自动办。”**  
🔹 **“Copy 类型随便传，非 Copy 要小心。”**
# 1 stack、heap和stackframe

在rust中，将变量根据内存所在划分两种为两种类型：标量类型（Copy类型）和复合类型。只有数字、浮点数、字符、布尔值属于标量类型，变量及数据本身都存储在stack中。其余复合类型均属于heap指针类型，数据存储在heap中，但变量为stack中的指针，指向数据所在的heap。
## 1.1 rust中的内存释放机制
rust在执行时，会根据每个作用域（可以理解为一个大括号{}内的所有语句）生成一个作用域块即stackframe。作用域中所有创建的变量会生成一个stack保存在这个stackframe中。
当作用域执行完毕，会释放掉这个作用域的stackframe中的stack。如果stack是个heap指针，那么同时也要释放掉指针指向的heap。

这样产生的问题：如果一个作用域A中的指针变量A1赋值给另一个作用域B中的变量B1，当B执行完毕会释放B1的stack及其heap，那么回到A执行时，变量A1就变成了指向不存在heap的悬垂指针。如果继续使用A1会产生无法预测的问题，就是rust中的未定义行为。（标量类型不存在heap因此不会出现这种问题。）

stack和heap最根本的区别在于，stack在所属stackframe结束后必被释放，而heap可能不释放。
# 2 所有权
为了避免两个变量同时指向一个heap所引发的冲突。rust使用所有权机制来规定一个heap的归属。例如：
```rust
let a = String::from("Hello");
let b = a;
```
创建变量a时，a变量拥有字符串Hello的heap的所有权。而a赋值给b时，是将字符串Hello的heap也转移给了b，这一过程被称为==所有权转移==。此时a的指针是个==被移动变量==（注意不是空指针，空指针是运行时概念，rust编译不允许出现空指针），不能被再次使用。
==所有权是单向流动的，所有权转移后就再也拿不回来了！==
==所有权和所有权的转移是个纯编译时概念，仅用作编译时检查。运行时没有这个概念。==
## 2.1 函数中的变量所有权
rust中函数在执行时，会创建一个函数作用域的stackframe，同时根据函数参数创建若干个stack，并将传入的变量的所有权转移给这些stack。这一过程中如果没有特殊声明也会发生所有权转移。函数作用域结束后参数的stack被释放。原先的变量不能再使用。
```rust
fn main() {
	let mut s = String::from("Hello");
	take_owner(s)
	println!("{s}") //报错，s已被释放
}
fn take_owner(s: String) {
	s.push_string("world")
}
```
# 3 引用
如果我们想在赋值时不转移所有权，有两种方式：克隆clone和借用borrow。
## 3.1 克隆
```rust
let a = String::from("hello");
let b = a.clone();
println!("{a}");  //仍然可以使用a
```
## 3.2 借用（引用）
借用也称引用，是指在新变量赋值旧变量时，stack指针不指向旧变量指针的heap，而是指向旧变量本身的stack，也就是==指向指针的指针==，heap的所有权仍属于旧变量。这样销毁新变量时，旧变量及其heap不受影响。引用分为2种使用方法：
### 3.2.1 直接引用：
```rust
let a = String::from("Hello");
let b = &a;
```
### 3.2.2 函数参数引用：
不可变参数引用：
```rust
fn main() {
	let s = String::from("Hello");
	borrow_string(&s);
	println!("{s}");
}
fn borrow_string(s: &String) {
	println!("{s}");
}
```
可变引用参数：
```rust
fn main() {
	let mut s = String::from("Hello");
	let s2 = mut_borrow_string(&mut s);
	println!("{s2}");
	//s2是s的引用，注意s2是不可变引用
}
fn mut_borrow_string(s: &mut String) {
	s.push_str("world");
	s; //push_str不返回值，需要手动返回s
}
```
使用可变引用作为参数的函数，传入的变量必须也是mut变量。
### 3.2.3 方法引用
绝大多数复合类型变量的方法都是创建其可变引用来进行操作，因此在调用方法时不需要再创建额外引用：
```rust
let mut s = String::from("AAA");
s.insert_str(0, "foo") //相当于insert_str(&mut s, 0, "foo")
```
### 3.3 解引用
使用`*`可以获取到引用变量指向的变量：
```rust
let b = Box::new(2);
let b2 = &b;
let origin = *b; //相当于origin = b 
let two = **b; //two = 2
```
### 3.4 内存示意图
```rust
let s = String::from("hello"); // s: String
let r1: &String = &s;
let r2: &str = &s[..]
```
String结构体s和引用r1、切片引用r2在内存中是这样的：
```
stack
| s (String)
| ptr: 0x1000
| len: 5
| cap: 5
| r1 (&String)
| addr: &s          | → 指向s的栈地址
| r2 (&str)         |
| ptr: 0x1000       | → 直接指向堆数据
| len: 5  
heap
| 0x1000 → 'h','e','l','l','o' |
```
# 4 不可变引用与可变引用
==引用不发生所有权转移，但是会影响读取和修改的权限==
只有&是可变引用，即使被引用的变量是mut，引用也只能读取不能修改。
声明一个可变引用，要在被引用的变量名前加上&mut，表明这是一个可变引用。
rust中使用引用时要注意两个基本原则：
1 可变变量A存在一个可变引用B=&mut A，那么A不能有任何使用（包括读取）直到B被释放，也不能使用A的可变引用（&mut A、可变传参、可变方法）。
2 可变变量A如果存在不可变引用B=&A，那么A可以读或创建其他不可变引用，但不能使用A的可变引用。
简单地说：可变引用同一时间只能有一个，不可变引用可以有多个
例如：
```rust
let mut v = vec![1,2,3]; 
let num = &v[2]; 
v.push(4); //这行报错，num是可变引用但push使用了v的可变引用
println!("{num}");
```
这些代码不能编译通过，num是v的可变引用，push是个可变引用改变了vec的长度，使其内存地址发生了变化。之后num会变成一个垂悬指针。

```rust
let mut v1 = vec![1,2,3]; 
let mut v2 = &mut v1; 
v2.push(4); 
println!("{v1[0]}, {v2[1]}"); //这行报错，v2存在期间v1丧失了读取的权限
```
这些代码不能编译通过。v2是v1的可变引用，v2存在期间，v1是无法使用的。

```rust
let mut v1 = vec![1,2,3];
let v2 = &v1;
v1.push(4); //这行报错，v2存在但push使用了v1的可变引用
println!("{}, {}", v1[0], v2[1]);
```
还是不能编译通过。v2是v1的不可变引用，不能对v1使用可变引用push。

```rust
let mut s1 = String::from("hello");
let s2 = &s1;
println!("{}, {}", s1,  s2);
```
编译通过，s2是s1的不可变引用，也没有对s1进行可变引用，s1、s2都能读取。

```rust
let mut v = vec![1,2,3]; 
let num3 = &mut v[2]; 
*num3 ++;
let num1 = &mut v[0];
```
可以通过编译，对于集合类型，rust允许同时对其中的不同元素进行可变引用。
### 4.1 检查作用域
**==新版rust编译时会检查引用变量的“词法作用域”，即一个引用变量如果没有再次使用就认为其生命周期结束，原变量恢复了所有权限，即使引用变量和原变量还在一个作用域==**，例如：
```rust
let mut a = vec![1, 2, 3];
let b = &mut a;
b.push(4);// 使用 b
// b 从此以后不再使用，生命周期结束，此时a恢复读写的权限
println!("{:?}", a); //能编译通过，rust认为b已经归还了所有权限
```
反之，只要引用变量生命周期未结束，就不能对原变量进行修改。
```rust
fn ascii_capitalize(v: &mut Vec<char>) { 
	let c = &v[0]; 
	if c.is_ascii_lowercase() { 
		v[0] = c.to_ascii_uppercase(); 
	} 
}
```
这段代码看似不能编译通过，因为c是v的不可变引用，不能修改v，但`c.to_ascii_uppercase()`返回的是一个新的char，所以`c.to_ascii_uppercase()`运行结束后rust判断c已经结束使用，v恢复了修改权限。
# 5 slice
切片（slice）允许你引用集合中一段连续的元素序列，而不用引用整个集合。
创建一个用于在字符串中找到第一个词（第一个空格前的字符串）索引的函数：
```rust
fn first_word(s: &String) -> usize {
    // 将字符串转换成每个字符的字节值组成的数组，字符串"hello"的字节数组是[104, 101, 108, 108, 111]
    let bytes = s.as_bytes();
    // .iter()会返回一个迭代器，enumerate()将每次迭代包装为元组，元组中包含字节数组的索引和字节本身
    for (i, &item) in bytes.iter().enumerate() {
        // b' '表示空格的ASCII码的字节值。找到第一个空格，返回索引
        if item == b' ' {
           return i;
        }
    }
    //没有空格返回s的长度
    s.len()
}
```
这个函数没有问题但使用时并不安全：
```rust
let mut s = String::from("hello world");
let word = first_word(&s); // word=5
s.clear(); 
println!(word); //此时word仍然为5，即使s被清空。因此s并不安全
```
对于string、Vector这种在内存中占据连续空间的数据，可以使用slice切片创建对其中部分值的引用：
```rust
let mut s = String::from("Hello world")
let s1: &str = &s[0..5]; //s1是对s前五个字符的引用
let s2: &str = &s[6..11]; //s2是对s第6-11个字符的引用
```
使用切片创造的是一个不可变引用，这样。
==注意1：切片引用要使用&标注，返回的是一个&str类型而不是&String类型。str是一种特殊的宽指针（运行时才知道大小的指针），必须通过引用来使用。&str是对这个指针的引用==
==注意2：字符串切片比较特殊，使用的是字节索引而不是字符索引（字符的位置索引）！索引位置必须有效的UTF8字符边界内==
字符串转化为utf8编码后，每一个字节长度就是一个字节索引，例如：
```rust
let s = String::from("Hello 世界");
//这个字符串中每一个英文字母占1字节，空格占1字节，每个汉字占3字节，总共为12个字节
let s1 = &s[..5]; //s1为Hello的引用
let s2 = &s[6..8]; //运行时崩溃。6..8范围内的字节是"世"的前两个字节，无法组成一个完整字符
```
重写first_word函数：
```rust
fn first_word(s: &String) -> &str {
	let bytes = s.as_bytes();
	for (i, item) in bytes.iter.enumerate() {
		if (item == b' ') {
			return &s[..i] //s从开始到空格前字符位置的切片索引
		}
	}
	&s[..] //整个字符串的切片
}
```
## 5.1 字面量字符串
字面量字符串本身就是一个&str
```rust
let s = "Hello";
```
s实际上是一个&str而不是String。
对于使用字符串引用作为参数的函数，更推荐使用&str作为字符串参数的类型签名：
```
fn first_word(s: &str) -> &str
```