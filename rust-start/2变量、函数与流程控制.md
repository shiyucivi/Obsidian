# 1 变量类型
## 1.1 变量声明
变量声明：
```rust
let a = 6; //声明不可变变量
let mut b = 10; //声明可变变量
b += 1; //b = 11
```
常量声明时必须声明其类型：
```rust
const pi: f64 = 3.1415926;
```
## 1.1 标量类型（copy类型）
标量类型直接存储在stack中。标量类型变量在赋值时直接复制数据不涉及指针。因此不需要引用来进行传递，也不涉及所有权问题。
### 1.1.1 数字
数字包括整数与浮点数。其中整数包括有符号类型和无符号类型：
有符号：i8、i16、i32、i64、i128、isize（按照当前计算机的位数，64位相当于i64）
无符号：u8、u16、u32、u64、u128、usize
### 1.1.2 浮点数
浮点数都有符号。
f32：4字节浮点数
f64：8字节浮点数（默认的浮点数类型）
### 1.1.3 布尔值
`let value = true`  布尔值占1字节
#### 1.1.4 字符
`let a: char = 'A'` 一个字符占4字节
## 1.2 复合类型
### 1.2.1 元组
元组是将多个不同类型的值组进行组合的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。元组可以使用()进行解构赋值。
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;
```
### 1.2.2 数组
数组与元组的区别在于数组中元素类型必须相同。数组的长度也固定不能改变
数组通常是在栈内存上的一段连续空间中存储的。
```rust
let a = [1, 2, 3, 4, 5];
let b: [i32; 5] = [1, 2, 3, 4, 5]; //显式声明数组长度与类型
let c = [3; 5]; //相当于c = [3, 3, 3, 3, 3]
println!(a[0])
```
数组的索引的类型是usize而不是普通的整形。
注意一个与数组类似的类型vector。vector长度可以修改，使用比数组灵活得多。如果不确定用哪个应该尽量使用vector。
## 1.3 可变变量与不可变变量
不可变变量必须在定义时赋值，并且之后不能进行任何修改，也不能使用其可变引用。
除非所有权转移给了另一个可变变量。
# 2 函数
函数最后一个表达式默认为函数的返回，注意作为返回值的表达式后不要带分号，因为带分号会被判断为语句。
如果你在函数中想提前返回或在条件判断如if中返回，需要使用 return 关键字
```rust
fn plus_one(x: i32) -> i32 {
	x + 1
}
fn judge_bigger(x: i32, y: i32) -> bool {
	if x>y {
		return true;
	}
	false
}
```
# 3 条件判断
## 3.1 if
rust中没有隐式转换，if的判断条件必须为一个布尔值或返回布尔值的表达式。
```rust
fn main() {
	let number = 3;
	if number != 0 {
		println!("number was something other than zero");
	}
}
```
if else可以作为一个表达式使用，只要所有条件分支都有一个表达式作为结束：
```rust
let condition = true;
let number = if condition { 1 } else { 0 };
```
## 3.2 match
match与其他语言的switch类似，用于控制匹配。但，match中的列举必须穷尽！因此match只能用可穷尽的变量作为匹配符来匹配：
```rust
let mut truth = true;
match truth {
	true => println!("true"),
	false => println!("false"),
}
```
match更常用的做法是匹配枚举。
# 4 循环：
## 4.1 loop

## 3.2 while

## 3.3 for
```rust
let a = [10, 20, 30, 40, 50];
for element in a {
	println!("the value is: {element}");
}
for num in (0..4) {
	println!(num)
}
```
所有实现了Iterator（或IntoIterator） trait的数据都可以调用for循环。