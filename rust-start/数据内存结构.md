### 1 存储在stack上的类型
#### 1.1 整数
整数存储在栈中，i32占32位即4个字节
```
stack
| 0x1000   | 42   |
```
#### 1.2 char
char类型存储unicode字符，一个字符占4个字节
```
stack
| 0x1000   | 'a'   |
```
#### 1.3 元组
元组在stack上连续存储。编译器可能会在成员之间插入填充进行对齐。
```
let a: (u8, char, i32) = (42, 'a', 354)
stack
| 0x1000   | 42   |
| 0x1001   | 'a'  |
| 0x1002   | 354  |
```
#### 1.4 数组
数组在stack上连续存储。大小固定类型唯一。
```
let a: [i32; 3] = [33, 33, 33]
stack
| 0x1000   | 33  |
| 0x1001   | 33  |
| 0x1002   | 33  |
```
如果数组上的元素是需要存储在heap上的数据，那么stack上存储的是指向heap的指针的集合。
##### 1.4.1 数组切片
==所有的切片类型都是一个存储在stack上的胖指针，本身不拥有数据，而是**引用**内存中的一段连续数据。==
```
let arr = [10, 20, 30, 40, 50];
let slice = &arr[1..4];
stack
| 0x1000   | 10  |  
| 0x1001   | 20  |  <----- | ptr | 0x1001  |
| 0x1002   | 30  |         | len | 3       |
| 0x1003   | 40  |
| 0x1004   | 50  |
```
切片的ptr指向切片中的第一个元素的地址。通常一个切片引用占16字节。
#### 1.5 引用类型
stack上数据的引用指针也在stack上，数据为内存地址（瘦指针），在 64 位系统上，引用指针占 8 字节。
```
let a = 42; let b = &a;
stack
| 0x1000   | 42     |  a
| 0x1001   | 0x1000 |  b
```
### 2 存储在heap上的数据
#### 2.1 Vec
Vec在stack上是一个胖指针，Vec的数据在heap上连续存储。
Vec在stack上占24字节。
```
let a = vec![55, 66, 77]
stack                           Heap:
| ptr   | 0x5000_0000  |  ----> [55][66][77]
| len   | 3            |
| cap   | 4            |
```
cap表示已分配的i32（4字节）空间数，为避免频繁重分配rust一般会分配大于vec长度的空间数。
#### 2.2 字符串
String本质上是`Vec<u8>`，与Vec的内存结构完全一致。区别在于元素必须是utf8编码。
#### 2.3 Vec切片与字符串切片
Vec的切片也是存储在stack上的胖指针，切片中储存指向切片第一个元素的内存地址。
```
let a = vec![55, 66, 77, 88, 99]
let slice = &a[1,3]
stack                           Heap:
| ptr   | 0x5000_0000  |  ----> [66][77]
| len   | 2            |
```
##### 2.3.1 &String和&str
虽然&String和&str很多时候能够互换使用（隐式转换），但是二者在内存中的结构完全不同。
&String在栈上是一个瘦指针，是对String在栈上结构体的简单引用。
&str是一个胖指针，包含一个指向heap中切片位置的指针和一些元数据。
唯一特殊的是字面量字符串，虽然字面量字符串是字符串切片，但是不存储在heap上。而是内存中的静态区域。
### 3 结构体
#### 3.1 带字段的结构体
结构体本身存储在stack上，并且每个字段的空间相邻。存储时也会存在补齐机制，对每个字段占据的内存空间进行对齐。
```
struct Data {
  nums: Vec<i32>,
  dimension: (usize, usize)
}
let data = Data{
  vec![66, 77],
  dimension: (33, 44)
}
stack                                 Heap:
| nums        | 0x5000_07ff  |  ----> [66][77]
| nums.len    | 2            |
| nums.cap    | 4            |
| dimension.0 | 33           |
| dimension.1 | 44           |
```

#### 3.2 元组结构体
类似于带字段的结构体。分配在栈上。
#### 3.3 单元结构体
单元结构体是没有任何成员的结构体，不会分配内存。
### 4 枚举
#### 4.1 无数据枚举
rust会根据变体数量来决定，即能给存储最大变体。例如一个有两个变体的枚举的最大变体的整形为1，只需要u8即可存储，即每个变体占据1字节。
```
enums HttpStatus {
  Ok,
  Error
}
stack 
| Https::Ok         | 0  |
| HttpStatus::Error | 1  |
```
可以手动指定一个变体对应的整形，例如：
```
enums HttpStatus {
  Ok = 200,
  Error = 404
}
// 最大整形为404，需要16位即u16，每个变体占据2字节
```
#### 4.2 持有数据的枚举
```
enum UniType {
  Empty,
  Number(i32),
  Array(Vec<i32>)
}
let type1 = UniType::Array(vec![]);
let type2 = UniType::Number(77);
stack                          heap
| type1         | 2    |
| type1.ptr     | none |
| type1.cap     | 0    |
| type1.length  | 0    |
```
### 5 智能指针
#### 5.1 Box
box在栈上是一个瘦指针，只有一个机器字节即 8字节大小。
```
let b = Box::new(vec![22, 33, 44]);
stack                           heap
| 0x1000 | 0x2000_78ff  | ----> | ptr   | 0x3000_32ff  |  ----> [66][77]
                                | len   | 2            |
                                | cap   | 4            |
```