## 1 创建结构体
```rust
struct User {
  active: bool,
  username: &str,
  email: String
}

let user1 = User{
  email: String::from("cv@qq.com");
  username: "CV",
  active: true
}
```
结构体本身存储在stack中，其属性如果为复合类型则为heap指针。
解构赋值法：
```rust
let user2 = User {
  email: String::from("123@gmail.com"),
  ..user1
}
```
如果user1中的字段都未实现copy trait，则user1所有权转移给了user2。
## 2 Tuple Struct 元组结构体
```rust
struct Color(i32, i32, i32);
let red = Color(255, 0, 0);
```
## 3 结构体引用
```rust
Struct
struct Point {x: i32, y: i32}
let mut p = Point{x: 120, y: 30};
let x = &mut p.x;
//不能读取p中的属性
x += 1;
```
## 4 结构体的trait
```rust
struct Point {x: i32, y: i32}
let p = Point{x: 120, y: 30};
println!("{:?}", p);
//{:?}是一种debug调试方法
// 不能编译，结构体Point未实现trait Debug
```
trait可以理解为对一些结构体和类型的行为规范（接口）。与接口不同的是trait中既可以规范定义（例如方法的参数类型与返回值）也可以提供默认方法实现。
```rust
// 为Point实现trait Debug
#[derive(debug)]
struct Point {x: i32, y: i32}
```
`#[derive(debug)]`是rust编译器提供的语法糖，让编译器自动为类型实现 Debug trait。
## 5 结构体方法实现
```rust
impl Point {
  fn origin_distance(&self) -> u32 {
    (self.x.pow(2) + self.y.pow(2)).isqrt() as u32
  }
  fn calc_distance(&self, another: &Point) -> u32 {
    ((self.x - another.x).pow(2) + (self.y - another.y).pow(2)).isqrt() as u32
  }
}
//调用：
let p = Point{x: 120, y: 30};
let p2 = Point{x: 110, y: 20};
let od = p.originDistance();
//相当于
let od = Point::calDistance(p);
let pd = p.originDistance(&p2);
```
impl中，第一个参数为self（或&self、mut &self）的可以视为自身的方法。本质上是函数调用的语法糖。
如果一个方法的参数不是引用&self而是self，那么调用完成后会释放自身。