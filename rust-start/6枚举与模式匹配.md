## 1 创建枚举
枚举可以作为函数参数的类型
```rust
//IpKind有两种V4、V6变体
enum IpKind {
  V4, V6
}
let four = IpKind::V4;
//枚举可以作为参数的类型
fn route(iptype: IpIknd) {}

struct IpAddress {
  kind: IpKind,
  address: String
}
let host = IpAddress {
  kind: IpKind::V4,
  address: String::from("127.0.0.1")
};
```
枚举值也可以持有数据
```rust
enum IpKind {
  V4(String),
  V6(String)
}
let host = IpKind::V4(String::from("127.0.0.1"));
```
枚举也可以像struct一样实现方法：
```rust
enum IpKind {
  V4(String),
  V6(String)
}
impl IpKind {
  //self类型为IpKind枚举
  fn get_net_mask(&self) {}
}
```
==枚举值不能当作一个单独的类型来使用==，例如不存在类型IpKind::V4
## 2 Option Enum与模式匹配
option代表一个值可能存在（Option::None），也可能不存在（Some）
```rust
enum Option<T> {
  None,
  Some<T>
}
```
None代表Null，`Some<T>`表示为类型为T的一个枚举值。
```rust
let mut y: Option<usize> = Some(5);
y = Option::None;
//y要么为Some<usize>要么为None
```
Some不是一个函数，而是包装一个值为Option枚举，==Some包装的值是什么样Some就是什么样==。
通常使用match来匹配枚举中的所有枚举值：
```rust
let mut some_string = Some("hello");
//some_string是一个Some<&str>
match some_string {
  Some (i) => println!("{}", i),
  None => (),
}
```
match表达式必须匹配所有可能的值，可以匹配范围表达式，也可以用_来表示剩余未匹配的值 。
```rust
let x = 5;
match x {
  1 => println!("one"),
  2 => println!("two"),
  3..=10 => println!("three to ten"),
  _ => println!("something else"),
}
```
支持使用解构来匹配struct和tuple等。但是不能直接匹配不定长（运行时才知道长度）的String、Vectory和Array，但可以匹配字面量&str。

可以使用if let来单独匹配：
```rust
let some_number = Some(5);
if let Some(max) = some_number {
  println!("{}", max);
}
```
## 3 match的所有权问题

match表达式中匹配的结果是执行一个函数，如果函数的参数为匹配的变量本身而不是引用，就会发生所有权转移，match完成后匹配的变量被释放
```rust
let mut a_string = Some(String::from("hello"));
let some_string = Some("hello");
match a_string {
  Some (i) => println!("{}", i),
  None => (),
}
// 此时不能再使用a_string，在match中被转移所有权
match some_string {
  Some (i) => println!("{}", i),
  _ => (),
}
// 仍然可以使用some_string，因为本身是一个&str
```
## 4 使用枚举创建联合类型
枚举可以用来创建联合类型，表示一个变量属于这些类型中的一个
```rust
enum UnionType {
  Int(i32),
  Float(f32),
  String(String)
}
let variable_vec: Vec<UnionType> = vec![
  UnionType::Init(2793),
  UnionType::String(String::from("hello"))
]
```
### 5 包含结构体的枚举
```rust
struct Point {
    x: u64,
    y: u64,
}
enum Message {
    Resize { width: u64, height: u64 },
    Move(Point),
}
impl Point {
	fn process(&mut self, message: Message) {
		match message {
			Message::Resize{width, height} => { //不处理的字段可以用_代替
				self.x = width;
				self.y = height;
			},
			Message::Move(point) => {
				self.x += Point.x;
				self.y += point.y;
			}
		}
	}
}

```
