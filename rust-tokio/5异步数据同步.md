### 5.1 Arc与Mutex
`Arc<Mutex>`常被用于在多线程之间共享数据，也可以用于多个异步任务之间的共享。但是，标准库的Mutex是同步锁。在高并发时，如果多个异步任务都去读取某个锁，那么这些线程都会阻塞并且不会让出线程。
而且在.await的过程中使用锁，很容易出现一个异步任务刚占用锁因为await让出了线程，而下个任务中也去获取锁的话也因为获取不到而阻塞占用线程。从而造成死锁。
因此`Arc<Mutex>`只适用于锁竞争较少的情况。如果多个异步任务都需要用到锁，应该优先使用其他锁类型。
使用Mutex还有一个问题就是MutexGuard是不满足Send的类型。在线程切换时无法保证数据安全性。只能在没有await的代码块中使用，确保MutexGuard在线程转移前被释放。
### 5.2 异步锁
常用的异步锁包括`tokio::sync::Mutex`和`tokio::sync::RwLock`。
```rust
use tokio::sync::Mutex; 
async fn increment_and_do_stuff(mutex: &Mutex<i32>) { 
	let mut lock = mutex.lock().await; 
	*lock += 1; 
	do_something_async().await; 
} // 锁在这里被释放
```
异步锁最大的特点就是解锁是异步的，如果锁被其他任务占用会让出当前线程，避免阻塞线程。但是异步锁会带来额外的性能开销。
异步任务中，更推荐使用异步通信的方式来进行数据同步。即**通过共享内存来传递消息，而不是通过传递消息来共享内存**。