### 1 多线程异步
在main函数中我们可以快捷地使用`#[tokio::main]`创建异步运行时。但是这个宏无法直接用于`std::thread::spawn`创建的线程中。要在创建的从线程中使用异步运行时，有这些方式：
#### 1.1 `tokio::runtime::Handle`共享异步运行时
在主线程中创建一个异步运行时的handle，在从线程中也可以使用这个handle来创建异步线程：
```rust
use tokio;
use std::thread;
#[tokio::main] async fn main() { 
	let handle = tokio::runtime::Handle::current();
	thread::spawn(move || { 
		handle.spawn(async move { 
			println!("Running in main Tokio runtime"); 
		}); 
	});
}
```
这种方法的好处是两个线程共享一个异步运行时，缺点是运行时需要协调多线程会带来一部分性能损失并且存在生命周期问题。适用于两个线程长期需要异步通信的场景。
#### 1.2 各自维护自己的运行时
```rust
use std::thread; 
use tokio::runtime::{Builder, Runtime}; 
let handle = thread::spawn(|| { 
	// 创建线程独立的异步运行时
	let rt = Builder::new_current_thread() 
		.enable_all() // 启用 I/O、时间等 
		.build() 
		.unwrap(); 
	rt.block_on(async { 
		//具体异步任务
	}); 
});
```
这种方式叫单线程运行时，每个线程的异步运行时互不干扰。但无法进行异步通信。
### 2 tokio异步通道
tokio也提供了channel等用于在异步线程之间通信，这些通道的接收端和发送端不仅可以在异步线程之间通信，还有在多线程之间通信的能力。
#### 2.1 `mpsc::channel`
```rust
let handle = tokio::runtime::Handle::current();
let (tx_reply, mut rx_reply) = tokio::sync::mpsc::channel::<i32>(20);
//20代表这个channel的缓冲区域为20
let n = 1;
std::thread::spawn(move || {
	handle.spawn(async move {
		while let Some(n) = rx_reply.revc().await {
			println("{n}");
		}
	})
})
tx.reply.send(n).await.unwrap();
```
channel返回的Sender满足Send+Sync trait。可以在多线程之间克隆并发送。但是Reciver只满足了Send，只能在单一线程中使用或转移。
#### 2.2 `sync::broadcast`
broadcast的Sender和Reciver都满足Send+Sync。可以用于在多线程和多异步任务之间通信（需要放在`Arc<Receiver>`中）。
注意，broadcast通常使用`Sender::subscribe()`来创建多个Receiver。因为channel返回的rx无法克隆只能在一个线程中使用。
```rust
use tokio::sync::{broadcast};
let (tx, _) = broadcast::channel(10);
let mut rx = tx.subscribe();
thread::spawn(move || {
	let tx = tx.clone();
	//handle为异步运行时
	handle.spawn(async move { 
		tx.send("done"); 
	}); 
});
rx.await.unwrap();
```
#### 1.3 `sync::oneshot`
oneshot的Sender和reciver都只能.await一次。因此都只实现了Send：
```rust
use tokio::sync::oneshot; 
use std::thread;
let (tx, rx) = oneshot::channel(); // 从 std 线程向 Tokio 主运行时提交任务 
thread::spawn(move || {
	//handle为异步运行时
	handle.spawn(async move { 
		println!("Running in main Tokio runtime"); 
		let _ = tx.send("done"); 
	}); 
}); 
rx.await.unwrap();
```
#### 1.4 `sync::watch`
watch的Sender和Reciver均实现了Sender和Receiver