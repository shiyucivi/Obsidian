原子操作指的是CPU程序内部的最小操作单元，不能在继续分割的操作。操作一旦发生就必须完成。原子操作允许线程安全地读取和修改同一变量。
对于一些简单数据，我们可以直接使用原子类型数据而不使用Mutex或者RwLock。
### 1 使用Atomic作为全局变量
Atomic类型天生具有内部可变性和锁机制，无需声明mut或解锁释放锁。
```rust

use srd::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};

static R: AtomicU64 = AtomicU64::new(0);
fn add_n_times(n: u64) -> JoinHandle<()> { 
	thread::spawn(move || { 
		for _ in 0..n { 
			R.fetch_add(1, Ordering::Relaxed); 
		} 
	}) 
}
const N_TIMES: u64 = 10000000;
fn main() {
	const N_THREADS: usize = 10; //线程数
	let mut threads = Vec::with_capacity(N_THREADS); //线程的vec
	for _ in 0..N_THREADS { 
		threads.push(add_n_times(N_TIMES)); 
	} 
	for thread in threads { 
		thread.join().unwrap(); 
	}
}
```
这个例子中创建了10个线程，每个线程中都会对原子类型数字R进行循环加1的操作。
### 1.1 原子操作的内存顺序
枚举`atomic::Ordering`是用来控制原子操作的内存顺序的工具
