### 1 线程制造者
我们可以使用`thread::spawn(f)`来快速地创建一个从线程任务。如果想为这个线程配置更多内容，需要使用线程制造者。
```rust
use std::thread;
fn main() {
	thread::Builder::new()
		.name("Thread 1".into())  //线程名称，使用into自动转换为String
		.stack_size(4 * 1024 * 1024) //栈大小
		.spawn(||{
			//打印当前线程的名称
			println!("current thread is {}", thread::current().name().unwrap());
		})
		.unwrap().join().unwrap();
}
```
为线程命名的好处是便于快速定位错误线程位置。
rust默认线程栈的大小是2MB。但是主线程的栈大小由OS决定。
### 2 作用域线程Scope threads
作用域线程的生命周期受限于作用域。线程必须在作用域结束前结束（作用域会自动等待线程结束后再退出），从而无需手动管理JoinHandle。同时作用域线程可以安全地引用作用域内的数据，降低复杂性。
实战中应该优先使用作用域线程。
```rust
use std::thread;
fn main() {
	let a = String::from("hello");
	thread::scope(|s| {
		let b = String::from("world");
		for i in 0..5 {
			//创建作用域线程
			s.spawn(move || {
				thread::splee(Duration::from_secs(1));
				println!("{a}"); //捕获了a的只读引用
				println!("{b}"); //❌必须转移所有权后才能使用
			})
		}
	})
}
```
scope的闭包有一个默认参数s，表示作用域。再使用`s.spawn`创建线程。作用域线程中使用了作用域中的变量，这种捕获和普通闭包一样遵循最小所有权原则。只要变量在作用域线程的生命周期期间存活就可以引用。
而普通线程的闭包为了保证存活，只能捕获`'static`周期类型的变量。
注意：scope定义的作用域和spawn定义的作用域是不同的。scope中定义的变量不能在spawn的闭包中使用，除非使用move转移。
可以将多个闭包返回值相同的作用域线程放在一个vec中。这个vec可以转化为Iterator并调用map方法来对返回值做出进一步处理：
```rust
//多线程计算1-10000之和
const CHUNK_SIZE: usize = 10;

let range = 1..10000;
let vec: Vec<i32> = range.into_iter().collect();
let chunks = vec.chunks(CHUNK_SIZE);
let mut count = 0;

let sum = thread::scope(|s| {
	let mut handles = Vec::new();
    for chunk in chunks {
        let h = s.spawn(|| {
			 chunk.iter().sum::<i32>()
        });
		handles.push(h);
    };
    //h的类型是ScopedJoinHandle<'_, i32>
    handles.into_iter().map(|h|
	    h.join().unwrap()
	).sum::<i32>()
});
```
### 3 线程挂起与线程继续
条件变量(Condition Variables)经常和 `Mutex` 一起使用，可以让线程挂起
```rust
use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
	let pair = Arc::new((Mutex::new(false), Condvar::new()));
	let pair2 = pair.clone();
	thread::spawn(move || {
		let (lock, cvar) = &*pair2;
		let mut started = lock.lock().unwrap();
		*started = true;
		cvar.notify_one();
	});
	let (lock, cvar) = &*pair2;
	let mut started = lock.lock().unwrap();
	while !*started {
		started = cvar.wait(started).unwrap();
	}
}
```
这个例子中，从线程先获取到锁，然后将锁的数据置为true。主线程