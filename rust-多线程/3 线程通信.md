### 1 MPSC
mpsc是多生产者、单消费者的通信通道。
发送端的send方法会无阻塞发送一条消息，如果通道存在（即收发两端都存在）则返回Ok。
接收端的recv方法会在收到消息时返回Ok，通道存在但未收到消息时阻塞线程直到收到消息。如果发送端被关闭则返回Err。
```rust
import std::{mpsc, thread};
type Task = Box<dyn FnOnce() + Send + 'static>;
enum Msg {
	Call(Task),
	Quit,
};
fn main() {
	let (tx, rx) = mpsc::channel::<Msg>();
	let handle = thread::spawn(move || {
		while let Ok(msg) = rx.reveive() {
			match msg {
				Msg::Call(task) => task(),
				Msg::Quit => {
					println!("thread quit");
					break
				}
			}
		}
	});
	rx.send(Msg::Call(Box::new(|| {
		println!("hello from main thread")
	}))).unwrap();
	rx.send(Msg::Quit).unwrap();
	handle.join().unwrap();
}
```
发送的数据如果没有实现copy，那么通常需要转移所有权发送。
### 2 同步通道与异步通道
通道有两种类型：
异步通道：发送操作是异步的，发送者在发送时不会有阻塞，拥有无限容量的缓冲区；
同步通道：发生操作是同步的，缓冲区的大小是预先分配的固定大小，如果缓冲区溢出就会阻塞。
通道的send和reveive都会返回一个Result。如果Result为Err，通常代表通道的另一端被挂起或者终止，那么之后的操作将无法进行，通常使用unwrap来引发错误传播。
#### 2.1 异步通道
使用`mpsc::channel`创建的是异步通道：
```rust
use std::sync::mpsc; 
use std::thread; 
use std::time::Duration; 
fn main() {
	let (tx, rx) = mpsc::channel();
	let handle = thread::spawn(move|| {
		tx.send(1).unwrap();
	})
	thread::sleep(Duration::from_secs(3));
	let num = rx.receive().unwrap();
	handle.join().unwrap();
}

```
#### 2.2 同步通道
同步通道发送端发送时是阻塞的，只有接收端接收到消息才能结束阻塞
```rust
use std::sync::mpsc; 
use std::thread; 
use std::time::Duration; 
fn main() { 
	let (tx, rx)= mpsc::sync_channel(0); 
	let handle = thread::spawn(move || {
		tx.send(1).unwrap();
		println!("发送完成");
	}); 
	thread::sleep(Duration::from_secs(3)); 
	println!("receive {}", rx.recv().unwrap()); 
	handle.join().unwrap(); 
}
```
这里接收端睡眠了3秒，因此发送端发送时会被阻塞，等接收端睡眠完成后才会打印出发送完成。
`mpsc::sync_channel`接收的参数代表消息通道的缓存区大小。如果消息通道存在缓存空间，那么发送端发送之后消息会暂存到缓存中，发送端不会阻塞。如果消息通道没有缓存空间那么发送端会阻塞直到缓存区有剩余空间。

### 3 传输多种消息类型
一种通道只能传输一种消息类型。如果想传输多种消息，那么应该用枚举或者tarit object来声明多种类型。
### 4 特殊情况：`Arc<Mutex<Reciver>>`
有时我们会将接收端使用`Arc<Mutex>`包装并clone到多个线程中，但并不会所有接收端都接收到消息，而是随机一个线程的接收端接收到。
```rust
use std::sync::{Arc, Mutex, mpsc};
use std::thread;

fn main() {
	let (tx, rx) = mpsc::channel();
	let shared_rx = Arc::new(Mutex::new(rx));
	let rx1 = shared_rx.clone();
	let thread1 = thread::spawn(move|| {
		let msg = rx1.lock().unwrap().recv().unwrap();
	});
	let rx2 = shared_rx.clone();
	let thread2 = thread::spawn(move|| {
		let msg = rx2.lock().unwrap().recv().unwrap();
	});
	rx.send(1).unwrap();
	thread1.join().unwrap();
	thread2.join().unwrap();
}
```
第一个线程首先拿到锁并解锁，调用recv方法收到消息
第二个线程等待锁被释放并解锁，此时调用recv方法会因为接收不到消息阻塞线程，消息已经被第一个线程消耗掉。mpsc的消息通道会在接收后清空掉被接收的消息确保只有单一接收者。
### 5 通道关闭
当所有发送端被drop或接收者被drop后，通道会自动关闭。