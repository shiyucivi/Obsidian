### 1 static
static关键字定义的变量在整个程序运行期间有效，这个变量是个固定的内存地址。必须用常量初始化并声明类型。可以用来进行引用并在线程之间共享：
```rust
static data: [i32; 5] = [1,2,3,4,5];
static mut COUNT: u32 = 0;
fn main() {
	let mut handles = vec![];
	for _ in 1..100 {
		let handle = thread::spawn(|| {
			println!("{data}");
			unsafe {
				COUNT += 1;
			}
		})
		handles.push(h);
	}
	handles.into_iter().for_each(|h|h.join().unwrap());
}
```
==rust中的static数据必须声明在顶级作用域中，不能声明在任何函数中==
==只有实现了sync的类型才能使用static声明==
### 2 `Box::leak`指针
`Box::leak`是一个主动泄露内存地址的方法。表示一个内存地址永远不会被drop。
```rust
let data: &'static [i32; 5] = Box::leak(Box::new([1,2,3,4,5]));
fn main() {
	let mut handles = vec![];
	for _ in 1..100 {
		//这里data可以被安全地move，因为data实现了clone
		let handle = thread::spawn(move || {
			println!("{data}");
		})
		handles.push(h);
	}
	handles.into_iter().for_each(|h|h.join().unwrap());
}
```
### 3 Arc指针
Arc指针会将针对数据的操作包裹为原子化的操作，确保多线程安全性。
```rust
let data = Arc::new([1,2,3,4,5]);
fn main() {
	let mut handles = vec![];
	for _ in 1..100 {
		let local_data = data.clone();
		let handle = thread::spawn(move || {
			println!("{data}");
		})
		handles.push(h);
	}
	handles.into_iter().for_each(|h|h.join().unwrap());
}
```
### 4 单线程提供内部可变性的Cell与RefCell
#### 4.1 `Cell<T>`
Cell不是指针，而是提供了内部可变性的包装类型。允许在只有不可变引用`&Cell<T>`的情况下修改内部值。Cell没用实现sync只能用在单线程中。
想取得`Cell<T>`内部的值，有两种途径：
`T:Copy`可以通过get方法获取到内部值，获取到的是内部值的copy
`T:Default`可以通过take方法取出内部值，取出后Cell内部值为`Default::default`。
若想修改`Cell<T>`内部的值，有两种途径：
replace方法，替换掉内部值，返回原先的内部值
set方法，替换掉内部值，丢弃原先的内部值
```rust
use std::cell::Cell; 
let counter = Cell::new(0); 
counter.set(10); 
assert_eq!(counter.get(), 10); // get() 返回的是拷贝值

let str_cell = Cell::new(String::from("hello"));
assert_eq!(str_cell.take(), "hello");
assert_eq!(str_cell.take(), String::default());
```
Cell通常用于简单数据类型。没用运行时开销也没有运行时借用检查。
与RefCell类似的地方在于都实现了内部可变性，并且可以与Rc搭配使用实现共享可变状态。不同之处在于Cell不能获取内部值的引用。通常用于一些简单的状态例如计数器和标志位。
#### 4.2 `RefCell<T>`
`RefCell<T>`通常用于copy消耗较大的类型，可以提供内部值的引用访问。内部维护一个计数器来追踪引用数量。遵循借用检查器并需要一定的运行时开销。
提供了borrow、borrow_mut等方法来获取内部值的引用。
### 5 多线程提供内部可变性的指针
#### 5.1 mutex
Mutex是最常见的用于在线程间分享数据的类型，同一时刻只允许存在一个对数据的访问。
当一个mutex在一个线程被解锁而线程崩溃时，mutex会进入中毒状态。此时调用lock方法和try_lock方法会返回一个Result，其Error类型为PoisonError类型。这个类型提供了一个into_inner方法，方法返回MutexGuard守卫。
```rust
use std::{sync::Nutex, thread};
static NUMBERS: Mutex<Vec<i32>> = Mutex::new(Vec::new());
fn main() {
	let mut handles = vec![];
	for _ in 0..20 {
		let h = thread::spawn(||{
			let mut lock = Numbers.lock().unwrap();
			lock.push(1);
		})
		handles.push(h);
	}
	handles.into_iter().for_each(|)
}
```
#### 5.2 RwLock读写锁
RwLock相当于多线程版本的RefCell。同一时刻允许多个只读访问或一个读写访问。同一时刻存在三个状态：未锁定、多个读取锁定、独占写入锁定。
RwLock提供了read方法来进行读取锁定，返回一个`RwLockReadGuard<T>`指针，这个指针类似于`MutexGuard`，实现了Deref trait。
RwLock的write方法进行独占写入锁定，返回一个`RwLockWriteGuard<T>`指针，这个指针实现了DerefMut trait。
RwLock包裹的类型必须是Send+Sync的。
```rust
use std::sync::{Arc, RwLock};

fn main() {
	let count = Arc::new(RwLock::new(3));
	{
		let count = count.clone();
		let h = thread::spawn(move ||{
			let value = count.read().unwrap();
			println("{value}");
		})
	}
	{
		let count = count.clone();
		let h = thread::spawn(move ||{
			let val = count.write().unwrap();
			*val+=1;
		})
	}
}
```
多线程中也需要使用Arc包裹来保证生命周期。
### 6 单次初始化的OnceCell和OneLock
OnceCell和OneLock是构建单例模式的核心工具。内部值在整个程序生命周期中只初始化一次，不能再修改，然后就可以多次读取。
#### 6.1 OnceCell
OnceCell可以获得内部值的一个引用，并且不需要运行时检查。
get方法：获取内部值的引用
set方法：进行初始化设置，返回一个Result
get_or_init：返回内部值，如果没用则初始化，需要闭包作为参数
get_mut：如果对OnceCell本身有一个可变引用，那么可以获取到内部值的可变引用。
```rust
use std::cell::OnceCell
fn main() {
	let cell = OnceCell::new();
	let result = cell.set(String::from("Hello"));
	assert_eq!(cell.get().unwrap(), "Hello");
}
```
#### 6.2 OnceLock
OnceLock是OnceCell的线程安全版本（Send+Sync）。可以配合Arc或static实现多线程安全访问。
```rust
use std::{sync::OnceLock, thread};
static LOCK: OnceLock<usize> = OnceLock::new();
fn main() {
	thread::spawn(||{
		let val = LOCK.get_or_init(|| 12345);
		assert_eq!(value, &12345);
	})
}
```
`OnceLock::get_or_init` 接收闭包而非直接接收值。这是因为get_or_init的语义就是延迟初始化的。若设计成先构造值再传入，则**无论是否需要，都必须承担构造成本**，违反了零成本原则。
### 7 延迟（按需）初始化的LazyCell和LazyLock
LazyCell、LazyLoack将值的创建推迟到首次访问时，并且只需声明一次初始化逻辑，无需在每次访问时重复提供。特别适合定义**全局静态变量**或**复杂结构中的惰性字段**。
OnceCell和OnceLock每次调用get_or_init时都需要传入一个相同的闭包。而LazyCell和LazyLock解决了这个问题，初始化时需要传入一个无参数的闭包，但这个闭包不会执行而是等到首次访问内部值的时候才执行。后续访问时直接返回内部值的引用。
LazyCell和LazyLock一经初始化，无法修改。
==对于需要按需初始化全局变量的场景，优先使用LazyCell和LazyLock==
#### 7.1 `LazyCell<T, F>`
```rust
use std::cell::LazyCell
fn main() {
	let lazy_val = LazyCell::new(|| {
		23
	}); //不会立即初始化
	println!("{}", *lazy_val); //首次访问时才初始化
	println!("{}", *lazy_val); //再次访问时返回&23
}
```
#### 7.2 `LazyLock<T, F>`
Lazy的线程安全版本。搭配Arc或者static使用。
LazyLock如果被多个线程调用，那么引用LazyLock的线程会等待初始化LazyLock的线程完成后再运行，此时引用线程被阻塞。
```rust
use std::{sync::LazyLock, thread};
static NUMBER: LazyLock<i32> = Lazy::new(|| {
	100
})
fn main() {
	(0..10).map(|_| {
		thread::spawn(|| {
			println!("{}", *NUMBER);
		})
	}).collect()
		.into_iter()
		.for_each(|h| {
			h.join().unwrap();
		});
}
```